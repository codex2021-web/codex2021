// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ops.proto
package com.codex.modelsheet.importmodel;
public final class Ops {
  private Ops() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface AggregateOpOrBuilder extends
      // @@protoc_insertion_point(interface_extends:AggregateOp)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code AggregateOp}
   */
  public static final class AggregateOp extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:AggregateOp)
      AggregateOpOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AggregateOp.newBuilder() to construct.
    private AggregateOp(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AggregateOp() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AggregateOp();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AggregateOp(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Ops.internal_static_AggregateOp_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Ops.internal_static_AggregateOp_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Ops.AggregateOp.class, Ops.AggregateOp.Builder.class);
    }

    /**
     * Protobuf enum {@code AggregateOp.E}
     */
    public enum E
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * These are the new names for the aggregate operations. Use these as much
       * as possible. Also, do not add any new names in the deprecated section
       * above.
       * </pre>
       *
       * <code>AGGR_NONE = 0;</code>
       */
      AGGR_NONE(0, 0),
      /**
       * <code>AGGR_SUM = 1;</code>
       */
      AGGR_SUM(1, 1),
      /**
       * <code>AGGR_AVERAGE = 2;</code>
       */
      AGGR_AVERAGE(2, 2),
      /**
       * <code>AGGR_COUNT_NON_NULL = 3;</code>
       */
      AGGR_COUNT_NON_NULL(3, 3),
      /**
       * <code>AGGR_MIN = 4;</code>
       */
      AGGR_MIN(4, 4),
      /**
       * <code>AGGR_MAX = 5;</code>
       */
      AGGR_MAX(5, 5),
      /**
       * <code>AGGR_VARIANCE = 6;</code>
       */
      AGGR_VARIANCE(6, 6),
      /**
       * <code>AGGR_STDEV = 7;</code>
       */
      AGGR_STDEV(7, 7),
      /**
       * <code>AGGR_GROWTH = 8;</code>
       */
      AGGR_GROWTH(8, 8),
      /**
       * <pre>
       * Alias for AGGR_PERCENTILE_CONT_WITHIN_GROUP with &#64;p = 0.5.
       * </pre>
       *
       * <code>AGGR_MEDIAN = 9;</code>
       */
      AGGR_MEDIAN(9, 9),
      /**
       * <code>AGGR_COUNT_DISTINCT = 10;</code>
       */
      AGGR_COUNT_DISTINCT(10, 10),
      /**
       * <code>AGGR_COUNT_WITH_NULL = 11;</code>
       */
      AGGR_COUNT_WITH_NULL(11, 11),
      /**
       * <code>AGGR_ROW_NUMBER = 12;</code>
       */
      AGGR_ROW_NUMBER(12, 12),
      /**
       * <code>AGGR_RANK = 13;</code>
       */
      AGGR_RANK(13, 13),
      /**
       * <code>AGGR_DENSE_RANK = 14;</code>
       */
      AGGR_DENSE_RANK(14, 14),
      /**
       * <code>AGGR_APPROX_COUNT_DISTINCT = 15;</code>
       */
      AGGR_APPROX_COUNT_DISTINCT(15, 15),
      /**
       * <code>AGGR_DISTINCT = 16;</code>
       */
      AGGR_DISTINCT(16, 16),
      /**
       * <code>AGGR_NTILE = 17;</code>
       */
      AGGR_NTILE(17, 17),
      /**
       * <code>AGGR_COUNT_DISTINCT_V1 = 19;</code>
       */
      AGGR_COUNT_DISTINCT_V1(18, 19),
      /**
       * <pre>
       * Interpolating inverse distribution function.
       * Takes percentile &#64;p and sort specification (WithinGroupDefinition).
       * </pre>
       *
       * <code>AGGR_PERCENTILE_CONT_WITHIN_GROUP = 20;</code>
       */
      AGGR_PERCENTILE_CONT_WITHIN_GROUP(19, 20),
      /**
       * <pre>
       * Non-interpolating inverse distribution function.
       * Takes percentile &#64;p and sort specification (WithinGroupDefinition).
       * </pre>
       *
       * <code>AGGR_PERCENTILE_DISC_WITHIN_GROUP = 21;</code>
       */
      AGGR_PERCENTILE_DISC_WITHIN_GROUP(20, 21),
      /**
       * <pre>
       * Number of breaks in value.
       * </pre>
       *
       * <code>AGGR_VALUE_BREAK = 22;</code>
       */
      AGGR_VALUE_BREAK(21, 22),
      /**
       * <pre>
       * Standard database PERCENT_RANK. Calculates the relative rank of a row
       * within a group of rows. The rank is normalized between 0.0 and 1.0. Only
       * usable with an OVER clause.
       * </pre>
       *
       * <code>AGGR_PERCENT_RANK = 23;</code>
       */
      AGGR_PERCENT_RANK(22, 23),
      /**
       * <pre>
       * Standard database count distinct (ignore nulls).
       * </pre>
       *
       * <code>AGGR_COUNT_DISTINCT_NON_NULL = 24;</code>
       */
      AGGR_COUNT_DISTINCT_NON_NULL(23, 24),
      /**
       * <pre>
       * Distinct version that ignores nulls. This is used in V2 count distinct
       * when we maintain a set of distinct values.
       * </pre>
       *
       * <code>AGGR_DISTINCT_NON_NULL = 25;</code>
       */
      AGGR_DISTINCT_NON_NULL(24, 25),
      /**
       * <code>AGGR_APPROX_DISTINCT = 26;</code>
       */
      AGGR_APPROX_DISTINCT(25, 26),
      /**
       * <code>AGGR_APPROX_DISTINCT_MERGE = 27;</code>
       */
      AGGR_APPROX_DISTINCT_MERGE(26, 27),
      /**
       * <pre>
       * Deprecated. Equivalent to AGGR_PERCENT_RANK(...) * 100.
       * </pre>
       *
       * <code>AGGR_RANK_PERCENTILE = 18;</code>
       */
      AGGR_RANK_PERCENTILE(40, 18),
      ;

      /**
       * <pre>
       * ---------------------- DEPRECATED_BEGIN ---------------------------------
       * These names are old aliases to the new names. They will continue to be
       * supported, but should not be used in new code. We will attempt to phase
       * them out gradually.
       * WARNING: Do NOT add new operator names in this deprecated section.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      public static final E NONE = AGGR_NONE;
      /**
       * <code>SUM = 1;</code>
       */
      public static final E SUM = AGGR_SUM;
      /**
       * <code>AVG = 2;</code>
       */
      public static final E AVG = AGGR_AVERAGE;
      /**
       * <pre>
       * this is just an alias for COUNT_NON_NULL
       * </pre>
       *
       * <code>COUNT = 3;</code>
       */
      public static final E COUNT = AGGR_COUNT_NON_NULL;
      /**
       * <code>COUNT_NON_NULL = 3;</code>
       */
      public static final E COUNT_NON_NULL = AGGR_COUNT_NON_NULL;
      /**
       * <code>MIN = 4;</code>
       */
      public static final E MIN = AGGR_MIN;
      /**
       * <code>MAX = 5;</code>
       */
      public static final E MAX = AGGR_MAX;
      /**
       * <code>VARIANCE = 6;</code>
       */
      public static final E VARIANCE = AGGR_VARIANCE;
      /**
       * <code>STDEV = 7;</code>
       */
      public static final E STDEV = AGGR_STDEV;
      /**
       * <code>GROWTH = 8;</code>
       */
      public static final E GROWTH = AGGR_GROWTH;
      /**
       * <code>MEDIAN = 9;</code>
       */
      public static final E MEDIAN = AGGR_MEDIAN;
      /**
       * <code>COUNT_DISTINCT = 10;</code>
       */
      public static final E COUNT_DISTINCT = AGGR_COUNT_DISTINCT;
      /**
       * <code>COUNT_WITH_NULL = 11;</code>
       */
      public static final E COUNT_WITH_NULL = AGGR_COUNT_WITH_NULL;
      /**
       * <pre>
       * These are the new names for the aggregate operations. Use these as much
       * as possible. Also, do not add any new names in the deprecated section
       * above.
       * </pre>
       *
       * <code>AGGR_NONE = 0;</code>
       */
      public static final int AGGR_NONE_VALUE = 0;
      /**
       * <code>AGGR_SUM = 1;</code>
       */
      public static final int AGGR_SUM_VALUE = 1;
      /**
       * <code>AGGR_AVERAGE = 2;</code>
       */
      public static final int AGGR_AVERAGE_VALUE = 2;
      /**
       * <code>AGGR_COUNT_NON_NULL = 3;</code>
       */
      public static final int AGGR_COUNT_NON_NULL_VALUE = 3;
      /**
       * <code>AGGR_MIN = 4;</code>
       */
      public static final int AGGR_MIN_VALUE = 4;
      /**
       * <code>AGGR_MAX = 5;</code>
       */
      public static final int AGGR_MAX_VALUE = 5;
      /**
       * <code>AGGR_VARIANCE = 6;</code>
       */
      public static final int AGGR_VARIANCE_VALUE = 6;
      /**
       * <code>AGGR_STDEV = 7;</code>
       */
      public static final int AGGR_STDEV_VALUE = 7;
      /**
       * <code>AGGR_GROWTH = 8;</code>
       */
      public static final int AGGR_GROWTH_VALUE = 8;
      /**
       * <pre>
       * Alias for AGGR_PERCENTILE_CONT_WITHIN_GROUP with &#64;p = 0.5.
       * </pre>
       *
       * <code>AGGR_MEDIAN = 9;</code>
       */
      public static final int AGGR_MEDIAN_VALUE = 9;
      /**
       * <code>AGGR_COUNT_DISTINCT = 10;</code>
       */
      public static final int AGGR_COUNT_DISTINCT_VALUE = 10;
      /**
       * <code>AGGR_COUNT_WITH_NULL = 11;</code>
       */
      public static final int AGGR_COUNT_WITH_NULL_VALUE = 11;
      /**
       * <code>AGGR_ROW_NUMBER = 12;</code>
       */
      public static final int AGGR_ROW_NUMBER_VALUE = 12;
      /**
       * <code>AGGR_RANK = 13;</code>
       */
      public static final int AGGR_RANK_VALUE = 13;
      /**
       * <code>AGGR_DENSE_RANK = 14;</code>
       */
      public static final int AGGR_DENSE_RANK_VALUE = 14;
      /**
       * <code>AGGR_APPROX_COUNT_DISTINCT = 15;</code>
       */
      public static final int AGGR_APPROX_COUNT_DISTINCT_VALUE = 15;
      /**
       * <code>AGGR_DISTINCT = 16;</code>
       */
      public static final int AGGR_DISTINCT_VALUE = 16;
      /**
       * <code>AGGR_NTILE = 17;</code>
       */
      public static final int AGGR_NTILE_VALUE = 17;
      /**
       * <code>AGGR_COUNT_DISTINCT_V1 = 19;</code>
       */
      public static final int AGGR_COUNT_DISTINCT_V1_VALUE = 19;
      /**
       * <pre>
       * Interpolating inverse distribution function.
       * Takes percentile &#64;p and sort specification (WithinGroupDefinition).
       * </pre>
       *
       * <code>AGGR_PERCENTILE_CONT_WITHIN_GROUP = 20;</code>
       */
      public static final int AGGR_PERCENTILE_CONT_WITHIN_GROUP_VALUE = 20;
      /**
       * <pre>
       * Non-interpolating inverse distribution function.
       * Takes percentile &#64;p and sort specification (WithinGroupDefinition).
       * </pre>
       *
       * <code>AGGR_PERCENTILE_DISC_WITHIN_GROUP = 21;</code>
       */
      public static final int AGGR_PERCENTILE_DISC_WITHIN_GROUP_VALUE = 21;
      /**
       * <pre>
       * Number of breaks in value.
       * </pre>
       *
       * <code>AGGR_VALUE_BREAK = 22;</code>
       */
      public static final int AGGR_VALUE_BREAK_VALUE = 22;
      /**
       * <pre>
       * Standard database PERCENT_RANK. Calculates the relative rank of a row
       * within a group of rows. The rank is normalized between 0.0 and 1.0. Only
       * usable with an OVER clause.
       * </pre>
       *
       * <code>AGGR_PERCENT_RANK = 23;</code>
       */
      public static final int AGGR_PERCENT_RANK_VALUE = 23;
      /**
       * <pre>
       * Standard database count distinct (ignore nulls).
       * </pre>
       *
       * <code>AGGR_COUNT_DISTINCT_NON_NULL = 24;</code>
       */
      public static final int AGGR_COUNT_DISTINCT_NON_NULL_VALUE = 24;
      /**
       * <pre>
       * Distinct version that ignores nulls. This is used in V2 count distinct
       * when we maintain a set of distinct values.
       * </pre>
       *
       * <code>AGGR_DISTINCT_NON_NULL = 25;</code>
       */
      public static final int AGGR_DISTINCT_NON_NULL_VALUE = 25;
      /**
       * <code>AGGR_APPROX_DISTINCT = 26;</code>
       */
      public static final int AGGR_APPROX_DISTINCT_VALUE = 26;
      /**
       * <code>AGGR_APPROX_DISTINCT_MERGE = 27;</code>
       */
      public static final int AGGR_APPROX_DISTINCT_MERGE_VALUE = 27;
      /**
       * <pre>
       * ---------------------- DEPRECATED_BEGIN ---------------------------------
       * These names are old aliases to the new names. They will continue to be
       * supported, but should not be used in new code. We will attempt to phase
       * them out gradually.
       * WARNING: Do NOT add new operator names in this deprecated section.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <code>SUM = 1;</code>
       */
      public static final int SUM_VALUE = 1;
      /**
       * <code>AVG = 2;</code>
       */
      public static final int AVG_VALUE = 2;
      /**
       * <pre>
       * this is just an alias for COUNT_NON_NULL
       * </pre>
       *
       * <code>COUNT = 3;</code>
       */
      public static final int COUNT_VALUE = 3;
      /**
       * <code>COUNT_NON_NULL = 3;</code>
       */
      public static final int COUNT_NON_NULL_VALUE = 3;
      /**
       * <code>MIN = 4;</code>
       */
      public static final int MIN_VALUE = 4;
      /**
       * <code>MAX = 5;</code>
       */
      public static final int MAX_VALUE = 5;
      /**
       * <code>VARIANCE = 6;</code>
       */
      public static final int VARIANCE_VALUE = 6;
      /**
       * <code>STDEV = 7;</code>
       */
      public static final int STDEV_VALUE = 7;
      /**
       * <code>GROWTH = 8;</code>
       */
      public static final int GROWTH_VALUE = 8;
      /**
       * <code>MEDIAN = 9;</code>
       */
      public static final int MEDIAN_VALUE = 9;
      /**
       * <code>COUNT_DISTINCT = 10;</code>
       */
      public static final int COUNT_DISTINCT_VALUE = 10;
      /**
       * <code>COUNT_WITH_NULL = 11;</code>
       */
      public static final int COUNT_WITH_NULL_VALUE = 11;
      /**
       * <pre>
       * Deprecated. Equivalent to AGGR_PERCENT_RANK(...) * 100.
       * </pre>
       *
       * <code>AGGR_RANK_PERCENTILE = 18;</code>
       */
      public static final int AGGR_RANK_PERCENTILE_VALUE = 18;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static E valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static E forNumber(int value) {
        switch (value) {
          case 0: return AGGR_NONE;
          case 1: return AGGR_SUM;
          case 2: return AGGR_AVERAGE;
          case 3: return AGGR_COUNT_NON_NULL;
          case 4: return AGGR_MIN;
          case 5: return AGGR_MAX;
          case 6: return AGGR_VARIANCE;
          case 7: return AGGR_STDEV;
          case 8: return AGGR_GROWTH;
          case 9: return AGGR_MEDIAN;
          case 10: return AGGR_COUNT_DISTINCT;
          case 11: return AGGR_COUNT_WITH_NULL;
          case 12: return AGGR_ROW_NUMBER;
          case 13: return AGGR_RANK;
          case 14: return AGGR_DENSE_RANK;
          case 15: return AGGR_APPROX_COUNT_DISTINCT;
          case 16: return AGGR_DISTINCT;
          case 17: return AGGR_NTILE;
          case 19: return AGGR_COUNT_DISTINCT_V1;
          case 20: return AGGR_PERCENTILE_CONT_WITHIN_GROUP;
          case 21: return AGGR_PERCENTILE_DISC_WITHIN_GROUP;
          case 22: return AGGR_VALUE_BREAK;
          case 23: return AGGR_PERCENT_RANK;
          case 24: return AGGR_COUNT_DISTINCT_NON_NULL;
          case 25: return AGGR_DISTINCT_NON_NULL;
          case 26: return AGGR_APPROX_DISTINCT;
          case 27: return AGGR_APPROX_DISTINCT_MERGE;
          case 18: return AGGR_RANK_PERCENTILE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<E>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          E> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<E>() {
              public E findValueByNumber(int number) {
                return E.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return Ops.AggregateOp.getDescriptor().getEnumTypes().get(0);
      }

      private static final E[] VALUES = getStaticValuesArray();
      private static E[] getStaticValuesArray() {
        return new E[] {
          AGGR_NONE, AGGR_SUM, AGGR_AVERAGE, AGGR_COUNT_NON_NULL, AGGR_MIN, AGGR_MAX, AGGR_VARIANCE, AGGR_STDEV, AGGR_GROWTH, AGGR_MEDIAN, AGGR_COUNT_DISTINCT, AGGR_COUNT_WITH_NULL, AGGR_ROW_NUMBER, AGGR_RANK, AGGR_DENSE_RANK, AGGR_APPROX_COUNT_DISTINCT, AGGR_DISTINCT, AGGR_NTILE, AGGR_COUNT_DISTINCT_V1, AGGR_PERCENTILE_CONT_WITHIN_GROUP, AGGR_PERCENTILE_DISC_WITHIN_GROUP, AGGR_VALUE_BREAK, AGGR_PERCENT_RANK, AGGR_COUNT_DISTINCT_NON_NULL, AGGR_DISTINCT_NON_NULL, AGGR_APPROX_DISTINCT, AGGR_APPROX_DISTINCT_MERGE, NONE, SUM, AVG, COUNT, COUNT_NON_NULL, MIN, MAX, VARIANCE, STDEV, GROWTH, MEDIAN, COUNT_DISTINCT, COUNT_WITH_NULL, AGGR_RANK_PERCENTILE, 
        };
      }
      public static E valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private E(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:AggregateOp.E)
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Ops.AggregateOp)) {
        return super.equals(obj);
      }
      Ops.AggregateOp other = (Ops.AggregateOp) obj;

      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Ops.AggregateOp parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Ops.AggregateOp parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Ops.AggregateOp parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Ops.AggregateOp parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Ops.AggregateOp parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Ops.AggregateOp parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Ops.AggregateOp parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Ops.AggregateOp parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static Ops.AggregateOp parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static Ops.AggregateOp parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Ops.AggregateOp parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Ops.AggregateOp parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Ops.AggregateOp prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code AggregateOp}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:AggregateOp)
        Ops.AggregateOpOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Ops.internal_static_AggregateOp_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Ops.internal_static_AggregateOp_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Ops.AggregateOp.class, Ops.AggregateOp.Builder.class);
      }

      // Construct using Ops.AggregateOp.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Ops.internal_static_AggregateOp_descriptor;
      }

      @java.lang.Override
      public Ops.AggregateOp getDefaultInstanceForType() {
        return Ops.AggregateOp.getDefaultInstance();
      }

      @java.lang.Override
      public Ops.AggregateOp build() {
        Ops.AggregateOp result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Ops.AggregateOp buildPartial() {
        Ops.AggregateOp result = new Ops.AggregateOp(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Ops.AggregateOp) {
          return mergeFrom((Ops.AggregateOp)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Ops.AggregateOp other) {
        if (other == Ops.AggregateOp.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Ops.AggregateOp parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (Ops.AggregateOp) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:AggregateOp)
    }

    // @@protoc_insertion_point(class_scope:AggregateOp)
    private static final Ops.AggregateOp DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Ops.AggregateOp();
    }

    public static Ops.AggregateOp getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<AggregateOp>
        PARSER = new com.google.protobuf.AbstractParser<AggregateOp>() {
      @java.lang.Override
      public AggregateOp parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AggregateOp(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AggregateOp> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AggregateOp> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Ops.AggregateOp getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ExpressionOpOrBuilder extends
      // @@protoc_insertion_point(interface_extends:ExpressionOp)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code ExpressionOp}
   */
  public static final class ExpressionOp extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:ExpressionOp)
      ExpressionOpOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ExpressionOp.newBuilder() to construct.
    private ExpressionOp(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ExpressionOp() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ExpressionOp();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ExpressionOp(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Ops.internal_static_ExpressionOp_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Ops.internal_static_ExpressionOp_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Ops.ExpressionOp.class, Ops.ExpressionOp.Builder.class);
    }

    /**
     * Protobuf enum {@code ExpressionOp.E}
     */
    public enum E
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * These are the new names for the expression operations. Use these as much
       * as possible. Also, do not add any new names in the deprecated section
       * above.
       * For details on these operators, see falcon/queryplan/expression_spec.txt
       * </pre>
       *
       * <code>OP_NONE = 0;</code>
       */
      OP_NONE(0),
      /**
       * <code>OP_PLUS = 1;</code>
       */
      OP_PLUS(1),
      /**
       * <code>OP_MINUS = 2;</code>
       */
      OP_MINUS(2),
      /**
       * <code>OP_MULTIPLY = 3;</code>
       */
      OP_MULTIPLY(3),
      /**
       * <code>OP_DIVIDE = 4;</code>
       */
      OP_DIVIDE(4),
      /**
       * <code>OP_MOD = 5;</code>
       */
      OP_MOD(5),
      /**
       * <code>OP_EXP = 6;</code>
       */
      OP_EXP(6),
      /**
       * <code>OP_ABS_YEAR = 7;</code>
       */
      OP_ABS_YEAR(7),
      /**
       * <code>OP_ABS_QUARTER = 8;</code>
       */
      OP_ABS_QUARTER(8),
      /**
       * <code>OP_ABS_MONTH = 9;</code>
       */
      OP_ABS_MONTH(9),
      /**
       * <code>OP_ABS_DAY = 10;</code>
       */
      OP_ABS_DAY(10),
      /**
       * <code>OP_QUARTER_IN_YEAR = 11;</code>
       */
      OP_QUARTER_IN_YEAR(11),
      /**
       * <code>OP_MONTH_IN_YEAR = 12;</code>
       */
      OP_MONTH_IN_YEAR(12),
      /**
       * <code>OP_DAY_IN_YEAR = 13;</code>
       */
      OP_DAY_IN_YEAR(13),
      /**
       * <code>OP_MONTH_IN_QUARTER = 14;</code>
       */
      OP_MONTH_IN_QUARTER(14),
      /**
       * <code>OP_DAY_IN_QUARTER = 15;</code>
       */
      OP_DAY_IN_QUARTER(15),
      /**
       * <code>OP_DAY_IN_MONTH = 16;</code>
       */
      OP_DAY_IN_MONTH(16),
      /**
       * <code>OP_DAY_OF_WEEK = 17;</code>
       */
      OP_DAY_OF_WEEK(17),
      /**
       * <code>OP_YEAR_START_EPOCH = 21;</code>
       */
      OP_YEAR_START_EPOCH(21),
      /**
       * <code>OP_QUARTER_START_EPOCH = 22;</code>
       */
      OP_QUARTER_START_EPOCH(22),
      /**
       * <code>OP_MONTH_START_EPOCH = 23;</code>
       */
      OP_MONTH_START_EPOCH(23),
      /**
       * <code>OP_DAY_START_EPOCH = 24;</code>
       */
      OP_DAY_START_EPOCH(24),
      /**
       * <code>OP_WEEK_IN_YEAR = 25;</code>
       */
      OP_WEEK_IN_YEAR(25),
      /**
       * <code>OP_WEEK_IN_QUARTER = 26;</code>
       */
      OP_WEEK_IN_QUARTER(26),
      /**
       * <code>OP_WEEK_IN_MONTH = 27;</code>
       */
      OP_WEEK_IN_MONTH(27),
      /**
       * <code>OP_WEEK_IN_YEAR_AS_EPOCH = 28;</code>
       */
      OP_WEEK_IN_YEAR_AS_EPOCH(28),
      /**
       * <code>OP_WEEK_IN_QUARTER_AS_EPOCH = 29;</code>
       */
      OP_WEEK_IN_QUARTER_AS_EPOCH(29),
      /**
       * <code>OP_WEEK_IN_MONTH_AS_EPOCH = 30;</code>
       */
      OP_WEEK_IN_MONTH_AS_EPOCH(30),
      /**
       * <code>OP_ABS_HOUR = 31;</code>
       */
      OP_ABS_HOUR(31),
      /**
       * <code>OP_HOUR_START_EPOCH = 32;</code>
       */
      OP_HOUR_START_EPOCH(32),
      /**
       * <code>OP_ABS_WEEK = 33;</code>
       */
      OP_ABS_WEEK(33),
      /**
       * <code>OP_WEEK_START_EPOCH = 34;</code>
       */
      OP_WEEK_START_EPOCH(34),
      /**
       * <code>OP_NOT = 35;</code>
       */
      OP_NOT(35),
      /**
       * <code>OP_SQRT = 36;</code>
       */
      OP_SQRT(36),
      /**
       * <pre>
       * Returns the string length in bytes.
       * </pre>
       *
       * <code>OP_STRLEN = 37;</code>
       */
      OP_STRLEN(37),
      /**
       * <code>OP_IS_NULL = 38;</code>
       */
      OP_IS_NULL(38),
      /**
       * <code>OP_EQUALS = 39;</code>
       */
      OP_EQUALS(39),
      /**
       * <code>OP_NOT_EQUALS = 40;</code>
       */
      OP_NOT_EQUALS(40),
      /**
       * <code>OP_LESS_THAN = 41;</code>
       */
      OP_LESS_THAN(41),
      /**
       * <code>OP_LESSER_EQUALS = 42;</code>
       */
      OP_LESSER_EQUALS(42),
      /**
       * <code>OP_GREATER_THAN = 43;</code>
       */
      OP_GREATER_THAN(43),
      /**
       * <code>OP_GREATER_EQUALS = 44;</code>
       */
      OP_GREATER_EQUALS(44),
      /**
       * <code>OP_AND = 45;</code>
       */
      OP_AND(45),
      /**
       * <code>OP_OR = 46;</code>
       */
      OP_OR(46),
      /**
       * <code>OP_BEGINS_WITH = 47;</code>
       */
      OP_BEGINS_WITH(47),
      /**
       * <code>OP_ENDS_WITH = 48;</code>
       */
      OP_ENDS_WITH(48),
      /**
       * <code>OP_CONTAINS = 49;</code>
       */
      OP_CONTAINS(49),
      /**
       * <code>OP_EQUALS_NOCASE = 50;</code>
       */
      OP_EQUALS_NOCASE(50),
      /**
       * <code>OP_NOT_EQUALS_NOCASE = 51;</code>
       */
      OP_NOT_EQUALS_NOCASE(51),
      /**
       * <code>OP_LESS_THAN_NOCASE = 52;</code>
       */
      OP_LESS_THAN_NOCASE(52),
      /**
       * <code>OP_LESSER_EQUALS_NOCASE = 53;</code>
       */
      OP_LESSER_EQUALS_NOCASE(53),
      /**
       * <code>OP_GREATER_THAN_NOCASE = 54;</code>
       */
      OP_GREATER_THAN_NOCASE(54),
      /**
       * <code>OP_GREATER_EQUALS_NOCASE = 55;</code>
       */
      OP_GREATER_EQUALS_NOCASE(55),
      /**
       * <code>OP_BEGINS_WITH_NOCASE = 56;</code>
       */
      OP_BEGINS_WITH_NOCASE(56),
      /**
       * <code>OP_ENDS_WITH_NOCASE = 57;</code>
       */
      OP_ENDS_WITH_NOCASE(57),
      /**
       * <code>OP_CONTAINS_NOCASE = 58;</code>
       */
      OP_CONTAINS_NOCASE(58),
      /**
       * <code>OP_NEGATE = 59;</code>
       */
      OP_NEGATE(59),
      /**
       * <code>OP_ABS = 60;</code>
       */
      OP_ABS(60),
      /**
       * <code>OP_FLOOR = 61;</code>
       */
      OP_FLOOR(61),
      /**
       * <code>OP_CEIL = 62;</code>
       */
      OP_CEIL(62),
      /**
       * <code>OP_SQUARE = 63;</code>
       */
      OP_SQUARE(63),
      /**
       * <code>OP_CUBE = 64;</code>
       */
      OP_CUBE(64),
      /**
       * <code>OP_CUBEROOT = 65;</code>
       */
      OP_CUBEROOT(65),
      /**
       * <code>OP_EXP2 = 66;</code>
       */
      OP_EXP2(66),
      /**
       * <code>OP_LN = 67;</code>
       */
      OP_LN(67),
      /**
       * <code>OP_LOG2 = 68;</code>
       */
      OP_LOG2(68),
      /**
       * <code>OP_LOG10 = 69;</code>
       */
      OP_LOG10(69),
      /**
       * <code>OP_SIGN = 70;</code>
       */
      OP_SIGN(70),
      /**
       * <code>OP_POW = 71;</code>
       */
      OP_POW(71),
      /**
       * <code>OP_LEAST = 72;</code>
       */
      OP_LEAST(72),
      /**
       * <code>OP_GREATEST = 73;</code>
       */
      OP_GREATEST(73),
      /**
       * <code>OP_DATE_DIFF_DAYS = 74;</code>
       */
      OP_DATE_DIFF_DAYS(74),
      /**
       * <code>OP_COS = 75;</code>
       */
      OP_COS(75),
      /**
       * <code>OP_SIN = 76;</code>
       */
      OP_SIN(76),
      /**
       * <code>OP_TAN = 77;</code>
       */
      OP_TAN(77),
      /**
       * <code>OP_ACOS = 78;</code>
       */
      OP_ACOS(78),
      /**
       * <code>OP_ASIN = 79;</code>
       */
      OP_ASIN(79),
      /**
       * <code>OP_ATAN = 80;</code>
       */
      OP_ATAN(80),
      /**
       * <code>OP_ATAN2 = 81;</code>
       */
      OP_ATAN2(81),
      /**
       * <code>OP_IF_NULL = 82;</code>
       */
      OP_IF_NULL(82),
      /**
       * <code>OP_IF = 83;</code>
       */
      OP_IF(83),
      /**
       * <code>OP_RANDOM = 84;</code>
       */
      OP_RANDOM(84),
      /**
       * <code>OP_ROUND = 85;</code>
       */
      OP_ROUND(85),
      /**
       * <pre>
       * STRPOS(haystack, needle) - string position.
       * If &#64;needle is found in &#64;haystack, the position (in bytes) is
       * returned (0-based). Otherwise, -1 is returned.
       * </pre>
       *
       * <code>OP_STRPOS = 86;</code>
       */
      OP_STRPOS(86),
      /**
       * <pre>
       * implemented in NaivePlanner
       * </pre>
       *
       * <code>OP_NOW = 87;</code>
       */
      OP_NOW(87),
      /**
       * <pre>
       * SUBSTR(string, start, len) - substring.
       * &#64;start (0-based) indicates starting byte.
       * &#64;len indicates length (in bytes).
       * &#64;len &lt; 0 is treated as 0.
       * </pre>
       *
       * <code>OP_SUBSTR = 88;</code>
       */
      OP_SUBSTR(88),
      /**
       * <code>OP_SPHERICAL_DISTANCE = 89;</code>
       */
      OP_SPHERICAL_DISTANCE(89),
      /**
       * <code>OP_IS_WEEKEND = 90;</code>
       */
      OP_IS_WEEKEND(90),
      /**
       * <code>OP_DAY_OF_WEEK_STR = 91;</code>
       */
      OP_DAY_OF_WEEK_STR(91),
      /**
       * <code>OP_DATE_ADD_DAYS = 92;</code>
       */
      OP_DATE_ADD_DAYS(92),
      /**
       * <code>OP_HOUR_IN_DAY = 93;</code>
       */
      OP_HOUR_IN_DAY(93),
      /**
       * <code>OP_SECOND_IN_DAY = 94;</code>
       */
      OP_SECOND_IN_DAY(94),
      /**
       * <code>OP_MONTH_IN_YEAR_STR = 95;</code>
       */
      OP_MONTH_IN_YEAR_STR(95),
      /**
       * <code>OP_IDENTITY = 96;</code>
       */
      OP_IDENTITY(96),
      /**
       * <code>OP_HASH = 97;</code>
       */
      OP_HASH(97),
      /**
       * <code>OP_COMBINE_HASH = 98;</code>
       */
      OP_COMBINE_HASH(98),
      /**
       * <code>OP_DATE_PARSE = 99;</code>
       */
      OP_DATE_PARSE(99),
      /**
       * <pre>
       * return time component of datetime or time field.
       * </pre>
       *
       * <code>OP_TIME_PART = 100;</code>
       */
      OP_TIME_PART(100),
      /**
       * <code>OP_STRCAT = 101;</code>
       */
      OP_STRCAT(101),
      /**
       * <code>OP_IN = 102;</code>
       */
      OP_IN(102),
      /**
       * <code>OP_CONVERT_BOOL_NUMERIC = 103;</code>
       */
      OP_CONVERT_BOOL_NUMERIC(103),
      /**
       * <code>OP_CONVERT_BOOL_STRING = 104;</code>
       */
      OP_CONVERT_BOOL_STRING(104),
      /**
       * <code>OP_CONVERT_NUMERIC_BOOL = 105;</code>
       */
      OP_CONVERT_NUMERIC_BOOL(105),
      /**
       * <code>OP_CONVERT_STRING_BOOL = 106;</code>
       */
      OP_CONVERT_STRING_BOOL(106),
      /**
       * <code>OP_CONVERT_FLOAT_INTEGER = 107;</code>
       */
      OP_CONVERT_FLOAT_INTEGER(107),
      /**
       * <code>OP_CONVERT_STRING_INT64 = 108;</code>
       */
      OP_CONVERT_STRING_INT64(108),
      /**
       * <code>OP_CONVERT_STRING_DOUBLE = 109;</code>
       */
      OP_CONVERT_STRING_DOUBLE(109),
      /**
       * <code>OP_CONVERT_INT64_STRING = 110;</code>
       */
      OP_CONVERT_INT64_STRING(110),
      /**
       * <code>OP_CONVERT_DOUBLE_STRING = 111;</code>
       */
      OP_CONVERT_DOUBLE_STRING(111),
      /**
       * <code>OP_CONVERT_DATE_STRING = 112;</code>
       */
      OP_CONVERT_DATE_STRING(112),
      /**
       * <pre>
       * returns true if strings are within 2 edit distance.
       * </pre>
       *
       * <code>OP_SPELLS_LIKE = 113;</code>
       */
      OP_SPELLS_LIKE(113),
      /**
       * <pre>
       * returns true if strings sounds similar.
       * </pre>
       *
       * <code>OP_SOUNDS_LIKE = 114;</code>
       */
      OP_SOUNDS_LIKE(114),
      /**
       * <pre>
       * returns true if OP_STRING_MATCH_SCORE &gt;= 0.2.
       * </pre>
       *
       * <code>OP_LIKE = 115;</code>
       */
      OP_LIKE(115),
      /**
       * <pre>
       * Edit-Distance &amp; Bag-Of-Words based score.
       * </pre>
       *
       * <code>OP_STRING_MATCH_SCORE = 116;</code>
       */
      OP_STRING_MATCH_SCORE(116),
      /**
       * <pre>
       * Edit Distance b/w 2 strings.
       * </pre>
       *
       * <code>OP_EDIT_DISTANCE = 117;</code>
       */
      OP_EDIT_DISTANCE(117),
      /**
       * <pre>
       * Computes Edit Distance b/w 2 strings if they are within specified cap.
       * Otherwise returns value greater than cap.
       * </pre>
       *
       * <code>OP_EDIT_DISTANCE_WITH_CAP = 118;</code>
       */
      OP_EDIT_DISTANCE_WITH_CAP(118),
      /**
       * <code>OP_TODAY = 119;</code>
       */
      OP_TODAY(119),
      /**
       * <pre>
       * Falcon Internal Use Only. Used for calculation of approx distinct count.
       * See falcon/queryplan/aggregator_impls.hpp for details.
       * </pre>
       *
       * <code>OP_APPROX_SET_CARDINALITY = 120;</code>
       */
      OP_APPROX_SET_CARDINALITY(120),
      /**
       * <pre>
       * Size of a set.
       * </pre>
       *
       * <code>OP_CONTAINER_SIZE = 121;</code>
       */
      OP_CONTAINER_SIZE(121),
      /**
       * <code>OP_CONVERT_STRING_FLOAT = 122;</code>
       */
      OP_CONVERT_STRING_FLOAT(122),
      /**
       * <pre>
       * Week number in a ISO-year. An ISO-year starts on first Monday 12.00am
       * before Jan 1st (similar to startofweek).
       * </pre>
       *
       * <code>OP_WEEK_IN_YEAR_ISO = 123;</code>
       */
      OP_WEEK_IN_YEAR_ISO(123),
      /**
       * <code>OP_CONVERT_INTEGER_DOUBLE = 124;</code>
       */
      OP_CONVERT_INTEGER_DOUBLE(124),
      /**
       * <code>OP_DATE_ADD_WEEKS = 127;</code>
       */
      OP_DATE_ADD_WEEKS(127),
      /**
       * <pre>
       * Add months operator
       * </pre>
       *
       * <code>OP_DATE_ADD_MONTHS = 128;</code>
       */
      OP_DATE_ADD_MONTHS(128),
      /**
       * <pre>
       * Add seconds to date/time/datetime.
       * </pre>
       *
       * <code>OP_DATE_TIME_ADD_SECONDS = 129;</code>
       */
      OP_DATE_TIME_ADD_SECONDS(129),
      /**
       * <pre>
       * Add minutes to date/time/datetime.
       * </pre>
       *
       * <code>OP_DATE_TIME_ADD_MINUTES = 130;</code>
       */
      OP_DATE_TIME_ADD_MINUTES(130),
      /**
       * <code>OP_DATE_ADD_YEARS = 131;</code>
       */
      OP_DATE_ADD_YEARS(131),
      /**
       * <pre>
       * Performs falcon's *internal* string normalization which both trims the
       * string and lowercases the string. Note given a TYPE_STRING_CASE it is a
       * no-op except case bytes are discarded. The resulting type is
       * TYPE_STRING.
       * </pre>
       *
       * <code>OP_NORMALIZE_STRING = 132;</code>
       */
      OP_NORMALIZE_STRING(132),
      /**
       * <pre>
       * Performs falcon's *internal* case-preserving string normalization which
       * both trims the string and lowercases the string (so comparisons are
       * case-insensitive) but retains case information by storing additional bits
       * after the end of the string that allow the original case to be
       * recovered. Note given a TYPE_STRING_CASE it is a no-op. The resulting
       * type is TYPE_STRING_CASE.
       * </pre>
       *
       * <code>OP_NORMALIZE_STRING_PRESERVE_CASE = 133;</code>
       */
      OP_NORMALIZE_STRING_PRESERVE_CASE(133),
      /**
       * <pre>
       * Extracts given number of chars from a string, starting from left/right
       * input: (string, no. of chars)
       * </pre>
       *
       * <code>OP_LEFT = 134;</code>
       */
      OP_LEFT(134),
      /**
       * <code>OP_RIGHT = 135;</code>
       */
      OP_RIGHT(135),
      /**
       * <pre>
       * Analogous to OP_STRLEN but counts the number of complete unicode
       * characters found in its string argument (instead of the length in bytes).
       * Note this method is not to be consumed publicly (use OP_STRLEN instead).
       * </pre>
       *
       * <code>OP_UTF8_STRLEN = 136;</code>
       */
      OP_UTF8_STRLEN(136),
      /**
       * <pre>
       * Analogous to OP_SUBSTR but the start and length parameters are treated as
       * number of complete unicode characters (instead of bytes).
       * Note this method is not to be consumed publicly (use OP_SUBSTR instead).
       * </pre>
       *
       * <code>OP_UTF8_SUBSTR = 137;</code>
       */
      OP_UTF8_SUBSTR(137),
      /**
       * <pre>
       * Analogous to OP_LEFT but the length parameter is treated as the desired
       * number of complete unicode characters (instead of bytes).
       * Note this method is not to be consumed publicly (use OP_LEFT instead).
       * </pre>
       *
       * <code>OP_UTF8_LEFT = 138;</code>
       */
      OP_UTF8_LEFT(138),
      /**
       * <pre>
       * Analogous to OP_RIGHT but the length parameter is treated as the desired
       * number of complete unicode characters (instead of bytes).
       * Note this method is not to be consumed publicly (use OP_RIGHT instead).
       * </pre>
       *
       * <code>OP_UTF8_RIGHT = 139;</code>
       */
      OP_UTF8_RIGHT(139),
      /**
       * <pre>
       * Analogous to OP_STRPOS but the position returned is the number of
       * complete utf-8 characters from the beginning (instead of bytes).
       * Note this method is not to be consumed publicly (use OP_STRPOS instead).
       * </pre>
       *
       * <code>OP_UTF8_STRPOS = 140;</code>
       */
      OP_UTF8_STRPOS(140),
      /**
       * <pre>
       * Every time add a new op, update OP_NUM_OPS.
       * </pre>
       *
       * <code>OP_NUM_OPS = 141;</code>
       */
      OP_NUM_OPS(141),
      ;

      /**
       * <pre>
       * ---------------------- DEPRECATED_BEGIN ---------------------------------
       * These names are old aliases to the new names. They will continue to be
       * supported, but should not be used in new code. We will attempt to phase
       * them out gradually.
       * WARNING: Do NOT add new operator names in this deprecated section.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      public static final E NONE = OP_NONE;
      /**
       * <code>SUM = 1;</code>
       */
      public static final E SUM = OP_PLUS;
      /**
       * <code>DIFF = 2;</code>
       */
      public static final E DIFF = OP_MINUS;
      /**
       * <code>MULT = 3;</code>
       */
      public static final E MULT = OP_MULTIPLY;
      /**
       * <code>DIV = 4;</code>
       */
      public static final E DIV = OP_DIVIDE;
      /**
       * <code>MOD = 5;</code>
       */
      public static final E MOD = OP_MOD;
      /**
       * <code>EXP = 6;</code>
       */
      public static final E EXP = OP_EXP;
      /**
       * <code>ABS_YEAR = 7;</code>
       */
      public static final E ABS_YEAR = OP_ABS_YEAR;
      /**
       * <code>ABS_QUARTER = 8;</code>
       */
      public static final E ABS_QUARTER = OP_ABS_QUARTER;
      /**
       * <code>ABS_MONTH = 9;</code>
       */
      public static final E ABS_MONTH = OP_ABS_MONTH;
      /**
       * <code>ABS_DAY = 10;</code>
       */
      public static final E ABS_DAY = OP_ABS_DAY;
      /**
       * <code>QUARTER_IN_YEAR = 11;</code>
       */
      public static final E QUARTER_IN_YEAR = OP_QUARTER_IN_YEAR;
      /**
       * <code>MONTH_IN_YEAR = 12;</code>
       */
      public static final E MONTH_IN_YEAR = OP_MONTH_IN_YEAR;
      /**
       * <code>DAY_IN_YEAR = 13;</code>
       */
      public static final E DAY_IN_YEAR = OP_DAY_IN_YEAR;
      /**
       * <code>MONTH_IN_QUARTER = 14;</code>
       */
      public static final E MONTH_IN_QUARTER = OP_MONTH_IN_QUARTER;
      /**
       * <code>DAY_IN_QUARTER = 15;</code>
       */
      public static final E DAY_IN_QUARTER = OP_DAY_IN_QUARTER;
      /**
       * <code>DAY_IN_MONTH = 16;</code>
       */
      public static final E DAY_IN_MONTH = OP_DAY_IN_MONTH;
      /**
       * <code>DAY_OF_WEEK = 17;</code>
       */
      public static final E DAY_OF_WEEK = OP_DAY_OF_WEEK;
      /**
       * <pre>
       * tags 18-20 unused
       * </pre>
       *
       * <code>ABS_YEAR_AS_EPOCH = 21;</code>
       */
      public static final E ABS_YEAR_AS_EPOCH = OP_YEAR_START_EPOCH;
      /**
       * <code>YEAR_START_EPOCH = 21;</code>
       */
      public static final E YEAR_START_EPOCH = OP_YEAR_START_EPOCH;
      /**
       * <code>ABS_QUARTER_AS_EPOCH = 22;</code>
       */
      public static final E ABS_QUARTER_AS_EPOCH = OP_QUARTER_START_EPOCH;
      /**
       * <code>QUARTER_START_EPOCH = 22;</code>
       */
      public static final E QUARTER_START_EPOCH = OP_QUARTER_START_EPOCH;
      /**
       * <code>ABS_MONTH_AS_EPOCH = 23;</code>
       */
      public static final E ABS_MONTH_AS_EPOCH = OP_MONTH_START_EPOCH;
      /**
       * <code>MONTH_START_EPOCH = 23;</code>
       */
      public static final E MONTH_START_EPOCH = OP_MONTH_START_EPOCH;
      /**
       * <code>ABS_DAY_AS_EPOCH = 24;</code>
       */
      public static final E ABS_DAY_AS_EPOCH = OP_DAY_START_EPOCH;
      /**
       * <code>DAY_START_EPOCH = 24;</code>
       */
      public static final E DAY_START_EPOCH = OP_DAY_START_EPOCH;
      /**
       * <code>WEEK_IN_YEAR = 25;</code>
       */
      public static final E WEEK_IN_YEAR = OP_WEEK_IN_YEAR;
      /**
       * <code>WEEK_IN_QUARTER = 26;</code>
       */
      public static final E WEEK_IN_QUARTER = OP_WEEK_IN_QUARTER;
      /**
       * <code>WEEK_IN_MONTH = 27;</code>
       */
      public static final E WEEK_IN_MONTH = OP_WEEK_IN_MONTH;
      /**
       * <code>WEEK_IN_YEAR_AS_EPOCH = 28;</code>
       */
      public static final E WEEK_IN_YEAR_AS_EPOCH = OP_WEEK_IN_YEAR_AS_EPOCH;
      /**
       * <code>WEEK_IN_QUARTER_AS_EPOCH = 29;</code>
       */
      public static final E WEEK_IN_QUARTER_AS_EPOCH = OP_WEEK_IN_QUARTER_AS_EPOCH;
      /**
       * <code>WEEK_IN_MONTH_AS_EPOCH = 30;</code>
       */
      public static final E WEEK_IN_MONTH_AS_EPOCH = OP_WEEK_IN_MONTH_AS_EPOCH;
      /**
       * <code>ABS_HOUR = 31;</code>
       */
      public static final E ABS_HOUR = OP_ABS_HOUR;
      /**
       * <code>ABS_HOUR_AS_EPOCH = 32;</code>
       */
      public static final E ABS_HOUR_AS_EPOCH = OP_HOUR_START_EPOCH;
      /**
       * <code>HOUR_START_EPOCH = 32;</code>
       */
      public static final E HOUR_START_EPOCH = OP_HOUR_START_EPOCH;
      /**
       * <code>ABS_WEEK = 33;</code>
       */
      public static final E ABS_WEEK = OP_ABS_WEEK;
      /**
       * <pre>
       * ---------------------- DEPRECATED_END -----------------------------------
       * </pre>
       *
       * <code>WEEK_START_EPOCH = 34;</code>
       */
      public static final E WEEK_START_EPOCH = OP_WEEK_START_EPOCH;
      /**
       * <pre>
       * These are the new names for the expression operations. Use these as much
       * as possible. Also, do not add any new names in the deprecated section
       * above.
       * For details on these operators, see falcon/queryplan/expression_spec.txt
       * </pre>
       *
       * <code>OP_NONE = 0;</code>
       */
      public static final int OP_NONE_VALUE = 0;
      /**
       * <code>OP_PLUS = 1;</code>
       */
      public static final int OP_PLUS_VALUE = 1;
      /**
       * <code>OP_MINUS = 2;</code>
       */
      public static final int OP_MINUS_VALUE = 2;
      /**
       * <code>OP_MULTIPLY = 3;</code>
       */
      public static final int OP_MULTIPLY_VALUE = 3;
      /**
       * <code>OP_DIVIDE = 4;</code>
       */
      public static final int OP_DIVIDE_VALUE = 4;
      /**
       * <code>OP_MOD = 5;</code>
       */
      public static final int OP_MOD_VALUE = 5;
      /**
       * <code>OP_EXP = 6;</code>
       */
      public static final int OP_EXP_VALUE = 6;
      /**
       * <code>OP_ABS_YEAR = 7;</code>
       */
      public static final int OP_ABS_YEAR_VALUE = 7;
      /**
       * <code>OP_ABS_QUARTER = 8;</code>
       */
      public static final int OP_ABS_QUARTER_VALUE = 8;
      /**
       * <code>OP_ABS_MONTH = 9;</code>
       */
      public static final int OP_ABS_MONTH_VALUE = 9;
      /**
       * <code>OP_ABS_DAY = 10;</code>
       */
      public static final int OP_ABS_DAY_VALUE = 10;
      /**
       * <code>OP_QUARTER_IN_YEAR = 11;</code>
       */
      public static final int OP_QUARTER_IN_YEAR_VALUE = 11;
      /**
       * <code>OP_MONTH_IN_YEAR = 12;</code>
       */
      public static final int OP_MONTH_IN_YEAR_VALUE = 12;
      /**
       * <code>OP_DAY_IN_YEAR = 13;</code>
       */
      public static final int OP_DAY_IN_YEAR_VALUE = 13;
      /**
       * <code>OP_MONTH_IN_QUARTER = 14;</code>
       */
      public static final int OP_MONTH_IN_QUARTER_VALUE = 14;
      /**
       * <code>OP_DAY_IN_QUARTER = 15;</code>
       */
      public static final int OP_DAY_IN_QUARTER_VALUE = 15;
      /**
       * <code>OP_DAY_IN_MONTH = 16;</code>
       */
      public static final int OP_DAY_IN_MONTH_VALUE = 16;
      /**
       * <code>OP_DAY_OF_WEEK = 17;</code>
       */
      public static final int OP_DAY_OF_WEEK_VALUE = 17;
      /**
       * <code>OP_YEAR_START_EPOCH = 21;</code>
       */
      public static final int OP_YEAR_START_EPOCH_VALUE = 21;
      /**
       * <code>OP_QUARTER_START_EPOCH = 22;</code>
       */
      public static final int OP_QUARTER_START_EPOCH_VALUE = 22;
      /**
       * <code>OP_MONTH_START_EPOCH = 23;</code>
       */
      public static final int OP_MONTH_START_EPOCH_VALUE = 23;
      /**
       * <code>OP_DAY_START_EPOCH = 24;</code>
       */
      public static final int OP_DAY_START_EPOCH_VALUE = 24;
      /**
       * <code>OP_WEEK_IN_YEAR = 25;</code>
       */
      public static final int OP_WEEK_IN_YEAR_VALUE = 25;
      /**
       * <code>OP_WEEK_IN_QUARTER = 26;</code>
       */
      public static final int OP_WEEK_IN_QUARTER_VALUE = 26;
      /**
       * <code>OP_WEEK_IN_MONTH = 27;</code>
       */
      public static final int OP_WEEK_IN_MONTH_VALUE = 27;
      /**
       * <code>OP_WEEK_IN_YEAR_AS_EPOCH = 28;</code>
       */
      public static final int OP_WEEK_IN_YEAR_AS_EPOCH_VALUE = 28;
      /**
       * <code>OP_WEEK_IN_QUARTER_AS_EPOCH = 29;</code>
       */
      public static final int OP_WEEK_IN_QUARTER_AS_EPOCH_VALUE = 29;
      /**
       * <code>OP_WEEK_IN_MONTH_AS_EPOCH = 30;</code>
       */
      public static final int OP_WEEK_IN_MONTH_AS_EPOCH_VALUE = 30;
      /**
       * <code>OP_ABS_HOUR = 31;</code>
       */
      public static final int OP_ABS_HOUR_VALUE = 31;
      /**
       * <code>OP_HOUR_START_EPOCH = 32;</code>
       */
      public static final int OP_HOUR_START_EPOCH_VALUE = 32;
      /**
       * <code>OP_ABS_WEEK = 33;</code>
       */
      public static final int OP_ABS_WEEK_VALUE = 33;
      /**
       * <code>OP_WEEK_START_EPOCH = 34;</code>
       */
      public static final int OP_WEEK_START_EPOCH_VALUE = 34;
      /**
       * <code>OP_NOT = 35;</code>
       */
      public static final int OP_NOT_VALUE = 35;
      /**
       * <code>OP_SQRT = 36;</code>
       */
      public static final int OP_SQRT_VALUE = 36;
      /**
       * <pre>
       * Returns the string length in bytes.
       * </pre>
       *
       * <code>OP_STRLEN = 37;</code>
       */
      public static final int OP_STRLEN_VALUE = 37;
      /**
       * <code>OP_IS_NULL = 38;</code>
       */
      public static final int OP_IS_NULL_VALUE = 38;
      /**
       * <code>OP_EQUALS = 39;</code>
       */
      public static final int OP_EQUALS_VALUE = 39;
      /**
       * <code>OP_NOT_EQUALS = 40;</code>
       */
      public static final int OP_NOT_EQUALS_VALUE = 40;
      /**
       * <code>OP_LESS_THAN = 41;</code>
       */
      public static final int OP_LESS_THAN_VALUE = 41;
      /**
       * <code>OP_LESSER_EQUALS = 42;</code>
       */
      public static final int OP_LESSER_EQUALS_VALUE = 42;
      /**
       * <code>OP_GREATER_THAN = 43;</code>
       */
      public static final int OP_GREATER_THAN_VALUE = 43;
      /**
       * <code>OP_GREATER_EQUALS = 44;</code>
       */
      public static final int OP_GREATER_EQUALS_VALUE = 44;
      /**
       * <code>OP_AND = 45;</code>
       */
      public static final int OP_AND_VALUE = 45;
      /**
       * <code>OP_OR = 46;</code>
       */
      public static final int OP_OR_VALUE = 46;
      /**
       * <code>OP_BEGINS_WITH = 47;</code>
       */
      public static final int OP_BEGINS_WITH_VALUE = 47;
      /**
       * <code>OP_ENDS_WITH = 48;</code>
       */
      public static final int OP_ENDS_WITH_VALUE = 48;
      /**
       * <code>OP_CONTAINS = 49;</code>
       */
      public static final int OP_CONTAINS_VALUE = 49;
      /**
       * <code>OP_EQUALS_NOCASE = 50;</code>
       */
      public static final int OP_EQUALS_NOCASE_VALUE = 50;
      /**
       * <code>OP_NOT_EQUALS_NOCASE = 51;</code>
       */
      public static final int OP_NOT_EQUALS_NOCASE_VALUE = 51;
      /**
       * <code>OP_LESS_THAN_NOCASE = 52;</code>
       */
      public static final int OP_LESS_THAN_NOCASE_VALUE = 52;
      /**
       * <code>OP_LESSER_EQUALS_NOCASE = 53;</code>
       */
      public static final int OP_LESSER_EQUALS_NOCASE_VALUE = 53;
      /**
       * <code>OP_GREATER_THAN_NOCASE = 54;</code>
       */
      public static final int OP_GREATER_THAN_NOCASE_VALUE = 54;
      /**
       * <code>OP_GREATER_EQUALS_NOCASE = 55;</code>
       */
      public static final int OP_GREATER_EQUALS_NOCASE_VALUE = 55;
      /**
       * <code>OP_BEGINS_WITH_NOCASE = 56;</code>
       */
      public static final int OP_BEGINS_WITH_NOCASE_VALUE = 56;
      /**
       * <code>OP_ENDS_WITH_NOCASE = 57;</code>
       */
      public static final int OP_ENDS_WITH_NOCASE_VALUE = 57;
      /**
       * <code>OP_CONTAINS_NOCASE = 58;</code>
       */
      public static final int OP_CONTAINS_NOCASE_VALUE = 58;
      /**
       * <code>OP_NEGATE = 59;</code>
       */
      public static final int OP_NEGATE_VALUE = 59;
      /**
       * <code>OP_ABS = 60;</code>
       */
      public static final int OP_ABS_VALUE = 60;
      /**
       * <code>OP_FLOOR = 61;</code>
       */
      public static final int OP_FLOOR_VALUE = 61;
      /**
       * <code>OP_CEIL = 62;</code>
       */
      public static final int OP_CEIL_VALUE = 62;
      /**
       * <code>OP_SQUARE = 63;</code>
       */
      public static final int OP_SQUARE_VALUE = 63;
      /**
       * <code>OP_CUBE = 64;</code>
       */
      public static final int OP_CUBE_VALUE = 64;
      /**
       * <code>OP_CUBEROOT = 65;</code>
       */
      public static final int OP_CUBEROOT_VALUE = 65;
      /**
       * <code>OP_EXP2 = 66;</code>
       */
      public static final int OP_EXP2_VALUE = 66;
      /**
       * <code>OP_LN = 67;</code>
       */
      public static final int OP_LN_VALUE = 67;
      /**
       * <code>OP_LOG2 = 68;</code>
       */
      public static final int OP_LOG2_VALUE = 68;
      /**
       * <code>OP_LOG10 = 69;</code>
       */
      public static final int OP_LOG10_VALUE = 69;
      /**
       * <code>OP_SIGN = 70;</code>
       */
      public static final int OP_SIGN_VALUE = 70;
      /**
       * <code>OP_POW = 71;</code>
       */
      public static final int OP_POW_VALUE = 71;
      /**
       * <code>OP_LEAST = 72;</code>
       */
      public static final int OP_LEAST_VALUE = 72;
      /**
       * <code>OP_GREATEST = 73;</code>
       */
      public static final int OP_GREATEST_VALUE = 73;
      /**
       * <code>OP_DATE_DIFF_DAYS = 74;</code>
       */
      public static final int OP_DATE_DIFF_DAYS_VALUE = 74;
      /**
       * <code>OP_COS = 75;</code>
       */
      public static final int OP_COS_VALUE = 75;
      /**
       * <code>OP_SIN = 76;</code>
       */
      public static final int OP_SIN_VALUE = 76;
      /**
       * <code>OP_TAN = 77;</code>
       */
      public static final int OP_TAN_VALUE = 77;
      /**
       * <code>OP_ACOS = 78;</code>
       */
      public static final int OP_ACOS_VALUE = 78;
      /**
       * <code>OP_ASIN = 79;</code>
       */
      public static final int OP_ASIN_VALUE = 79;
      /**
       * <code>OP_ATAN = 80;</code>
       */
      public static final int OP_ATAN_VALUE = 80;
      /**
       * <code>OP_ATAN2 = 81;</code>
       */
      public static final int OP_ATAN2_VALUE = 81;
      /**
       * <code>OP_IF_NULL = 82;</code>
       */
      public static final int OP_IF_NULL_VALUE = 82;
      /**
       * <code>OP_IF = 83;</code>
       */
      public static final int OP_IF_VALUE = 83;
      /**
       * <code>OP_RANDOM = 84;</code>
       */
      public static final int OP_RANDOM_VALUE = 84;
      /**
       * <code>OP_ROUND = 85;</code>
       */
      public static final int OP_ROUND_VALUE = 85;
      /**
       * <pre>
       * STRPOS(haystack, needle) - string position.
       * If &#64;needle is found in &#64;haystack, the position (in bytes) is
       * returned (0-based). Otherwise, -1 is returned.
       * </pre>
       *
       * <code>OP_STRPOS = 86;</code>
       */
      public static final int OP_STRPOS_VALUE = 86;
      /**
       * <pre>
       * implemented in NaivePlanner
       * </pre>
       *
       * <code>OP_NOW = 87;</code>
       */
      public static final int OP_NOW_VALUE = 87;
      /**
       * <pre>
       * SUBSTR(string, start, len) - substring.
       * &#64;start (0-based) indicates starting byte.
       * &#64;len indicates length (in bytes).
       * &#64;len &lt; 0 is treated as 0.
       * </pre>
       *
       * <code>OP_SUBSTR = 88;</code>
       */
      public static final int OP_SUBSTR_VALUE = 88;
      /**
       * <code>OP_SPHERICAL_DISTANCE = 89;</code>
       */
      public static final int OP_SPHERICAL_DISTANCE_VALUE = 89;
      /**
       * <code>OP_IS_WEEKEND = 90;</code>
       */
      public static final int OP_IS_WEEKEND_VALUE = 90;
      /**
       * <code>OP_DAY_OF_WEEK_STR = 91;</code>
       */
      public static final int OP_DAY_OF_WEEK_STR_VALUE = 91;
      /**
       * <code>OP_DATE_ADD_DAYS = 92;</code>
       */
      public static final int OP_DATE_ADD_DAYS_VALUE = 92;
      /**
       * <code>OP_HOUR_IN_DAY = 93;</code>
       */
      public static final int OP_HOUR_IN_DAY_VALUE = 93;
      /**
       * <code>OP_SECOND_IN_DAY = 94;</code>
       */
      public static final int OP_SECOND_IN_DAY_VALUE = 94;
      /**
       * <code>OP_MONTH_IN_YEAR_STR = 95;</code>
       */
      public static final int OP_MONTH_IN_YEAR_STR_VALUE = 95;
      /**
       * <code>OP_IDENTITY = 96;</code>
       */
      public static final int OP_IDENTITY_VALUE = 96;
      /**
       * <code>OP_HASH = 97;</code>
       */
      public static final int OP_HASH_VALUE = 97;
      /**
       * <code>OP_COMBINE_HASH = 98;</code>
       */
      public static final int OP_COMBINE_HASH_VALUE = 98;
      /**
       * <code>OP_DATE_PARSE = 99;</code>
       */
      public static final int OP_DATE_PARSE_VALUE = 99;
      /**
       * <pre>
       * return time component of datetime or time field.
       * </pre>
       *
       * <code>OP_TIME_PART = 100;</code>
       */
      public static final int OP_TIME_PART_VALUE = 100;
      /**
       * <code>OP_STRCAT = 101;</code>
       */
      public static final int OP_STRCAT_VALUE = 101;
      /**
       * <code>OP_IN = 102;</code>
       */
      public static final int OP_IN_VALUE = 102;
      /**
       * <code>OP_CONVERT_BOOL_NUMERIC = 103;</code>
       */
      public static final int OP_CONVERT_BOOL_NUMERIC_VALUE = 103;
      /**
       * <code>OP_CONVERT_BOOL_STRING = 104;</code>
       */
      public static final int OP_CONVERT_BOOL_STRING_VALUE = 104;
      /**
       * <code>OP_CONVERT_NUMERIC_BOOL = 105;</code>
       */
      public static final int OP_CONVERT_NUMERIC_BOOL_VALUE = 105;
      /**
       * <code>OP_CONVERT_STRING_BOOL = 106;</code>
       */
      public static final int OP_CONVERT_STRING_BOOL_VALUE = 106;
      /**
       * <code>OP_CONVERT_FLOAT_INTEGER = 107;</code>
       */
      public static final int OP_CONVERT_FLOAT_INTEGER_VALUE = 107;
      /**
       * <code>OP_CONVERT_STRING_INT64 = 108;</code>
       */
      public static final int OP_CONVERT_STRING_INT64_VALUE = 108;
      /**
       * <code>OP_CONVERT_STRING_DOUBLE = 109;</code>
       */
      public static final int OP_CONVERT_STRING_DOUBLE_VALUE = 109;
      /**
       * <code>OP_CONVERT_INT64_STRING = 110;</code>
       */
      public static final int OP_CONVERT_INT64_STRING_VALUE = 110;
      /**
       * <code>OP_CONVERT_DOUBLE_STRING = 111;</code>
       */
      public static final int OP_CONVERT_DOUBLE_STRING_VALUE = 111;
      /**
       * <code>OP_CONVERT_DATE_STRING = 112;</code>
       */
      public static final int OP_CONVERT_DATE_STRING_VALUE = 112;
      /**
       * <pre>
       * returns true if strings are within 2 edit distance.
       * </pre>
       *
       * <code>OP_SPELLS_LIKE = 113;</code>
       */
      public static final int OP_SPELLS_LIKE_VALUE = 113;
      /**
       * <pre>
       * returns true if strings sounds similar.
       * </pre>
       *
       * <code>OP_SOUNDS_LIKE = 114;</code>
       */
      public static final int OP_SOUNDS_LIKE_VALUE = 114;
      /**
       * <pre>
       * returns true if OP_STRING_MATCH_SCORE &gt;= 0.2.
       * </pre>
       *
       * <code>OP_LIKE = 115;</code>
       */
      public static final int OP_LIKE_VALUE = 115;
      /**
       * <pre>
       * Edit-Distance &amp; Bag-Of-Words based score.
       * </pre>
       *
       * <code>OP_STRING_MATCH_SCORE = 116;</code>
       */
      public static final int OP_STRING_MATCH_SCORE_VALUE = 116;
      /**
       * <pre>
       * Edit Distance b/w 2 strings.
       * </pre>
       *
       * <code>OP_EDIT_DISTANCE = 117;</code>
       */
      public static final int OP_EDIT_DISTANCE_VALUE = 117;
      /**
       * <pre>
       * Computes Edit Distance b/w 2 strings if they are within specified cap.
       * Otherwise returns value greater than cap.
       * </pre>
       *
       * <code>OP_EDIT_DISTANCE_WITH_CAP = 118;</code>
       */
      public static final int OP_EDIT_DISTANCE_WITH_CAP_VALUE = 118;
      /**
       * <code>OP_TODAY = 119;</code>
       */
      public static final int OP_TODAY_VALUE = 119;
      /**
       * <pre>
       * Falcon Internal Use Only. Used for calculation of approx distinct count.
       * See falcon/queryplan/aggregator_impls.hpp for details.
       * </pre>
       *
       * <code>OP_APPROX_SET_CARDINALITY = 120;</code>
       */
      public static final int OP_APPROX_SET_CARDINALITY_VALUE = 120;
      /**
       * <pre>
       * Size of a set.
       * </pre>
       *
       * <code>OP_CONTAINER_SIZE = 121;</code>
       */
      public static final int OP_CONTAINER_SIZE_VALUE = 121;
      /**
       * <code>OP_CONVERT_STRING_FLOAT = 122;</code>
       */
      public static final int OP_CONVERT_STRING_FLOAT_VALUE = 122;
      /**
       * <pre>
       * Week number in a ISO-year. An ISO-year starts on first Monday 12.00am
       * before Jan 1st (similar to startofweek).
       * </pre>
       *
       * <code>OP_WEEK_IN_YEAR_ISO = 123;</code>
       */
      public static final int OP_WEEK_IN_YEAR_ISO_VALUE = 123;
      /**
       * <code>OP_CONVERT_INTEGER_DOUBLE = 124;</code>
       */
      public static final int OP_CONVERT_INTEGER_DOUBLE_VALUE = 124;
      /**
       * <code>OP_DATE_ADD_WEEKS = 127;</code>
       */
      public static final int OP_DATE_ADD_WEEKS_VALUE = 127;
      /**
       * <pre>
       * Add months operator
       * </pre>
       *
       * <code>OP_DATE_ADD_MONTHS = 128;</code>
       */
      public static final int OP_DATE_ADD_MONTHS_VALUE = 128;
      /**
       * <pre>
       * Add seconds to date/time/datetime.
       * </pre>
       *
       * <code>OP_DATE_TIME_ADD_SECONDS = 129;</code>
       */
      public static final int OP_DATE_TIME_ADD_SECONDS_VALUE = 129;
      /**
       * <pre>
       * Add minutes to date/time/datetime.
       * </pre>
       *
       * <code>OP_DATE_TIME_ADD_MINUTES = 130;</code>
       */
      public static final int OP_DATE_TIME_ADD_MINUTES_VALUE = 130;
      /**
       * <code>OP_DATE_ADD_YEARS = 131;</code>
       */
      public static final int OP_DATE_ADD_YEARS_VALUE = 131;
      /**
       * <pre>
       * Performs falcon's *internal* string normalization which both trims the
       * string and lowercases the string. Note given a TYPE_STRING_CASE it is a
       * no-op except case bytes are discarded. The resulting type is
       * TYPE_STRING.
       * </pre>
       *
       * <code>OP_NORMALIZE_STRING = 132;</code>
       */
      public static final int OP_NORMALIZE_STRING_VALUE = 132;
      /**
       * <pre>
       * Performs falcon's *internal* case-preserving string normalization which
       * both trims the string and lowercases the string (so comparisons are
       * case-insensitive) but retains case information by storing additional bits
       * after the end of the string that allow the original case to be
       * recovered. Note given a TYPE_STRING_CASE it is a no-op. The resulting
       * type is TYPE_STRING_CASE.
       * </pre>
       *
       * <code>OP_NORMALIZE_STRING_PRESERVE_CASE = 133;</code>
       */
      public static final int OP_NORMALIZE_STRING_PRESERVE_CASE_VALUE = 133;
      /**
       * <pre>
       * Extracts given number of chars from a string, starting from left/right
       * input: (string, no. of chars)
       * </pre>
       *
       * <code>OP_LEFT = 134;</code>
       */
      public static final int OP_LEFT_VALUE = 134;
      /**
       * <code>OP_RIGHT = 135;</code>
       */
      public static final int OP_RIGHT_VALUE = 135;
      /**
       * <pre>
       * Analogous to OP_STRLEN but counts the number of complete unicode
       * characters found in its string argument (instead of the length in bytes).
       * Note this method is not to be consumed publicly (use OP_STRLEN instead).
       * </pre>
       *
       * <code>OP_UTF8_STRLEN = 136;</code>
       */
      public static final int OP_UTF8_STRLEN_VALUE = 136;
      /**
       * <pre>
       * Analogous to OP_SUBSTR but the start and length parameters are treated as
       * number of complete unicode characters (instead of bytes).
       * Note this method is not to be consumed publicly (use OP_SUBSTR instead).
       * </pre>
       *
       * <code>OP_UTF8_SUBSTR = 137;</code>
       */
      public static final int OP_UTF8_SUBSTR_VALUE = 137;
      /**
       * <pre>
       * Analogous to OP_LEFT but the length parameter is treated as the desired
       * number of complete unicode characters (instead of bytes).
       * Note this method is not to be consumed publicly (use OP_LEFT instead).
       * </pre>
       *
       * <code>OP_UTF8_LEFT = 138;</code>
       */
      public static final int OP_UTF8_LEFT_VALUE = 138;
      /**
       * <pre>
       * Analogous to OP_RIGHT but the length parameter is treated as the desired
       * number of complete unicode characters (instead of bytes).
       * Note this method is not to be consumed publicly (use OP_RIGHT instead).
       * </pre>
       *
       * <code>OP_UTF8_RIGHT = 139;</code>
       */
      public static final int OP_UTF8_RIGHT_VALUE = 139;
      /**
       * <pre>
       * Analogous to OP_STRPOS but the position returned is the number of
       * complete utf-8 characters from the beginning (instead of bytes).
       * Note this method is not to be consumed publicly (use OP_STRPOS instead).
       * </pre>
       *
       * <code>OP_UTF8_STRPOS = 140;</code>
       */
      public static final int OP_UTF8_STRPOS_VALUE = 140;
      /**
       * <pre>
       * Every time add a new op, update OP_NUM_OPS.
       * </pre>
       *
       * <code>OP_NUM_OPS = 141;</code>
       */
      public static final int OP_NUM_OPS_VALUE = 141;
      /**
       * <pre>
       * ---------------------- DEPRECATED_BEGIN ---------------------------------
       * These names are old aliases to the new names. They will continue to be
       * supported, but should not be used in new code. We will attempt to phase
       * them out gradually.
       * WARNING: Do NOT add new operator names in this deprecated section.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <code>SUM = 1;</code>
       */
      public static final int SUM_VALUE = 1;
      /**
       * <code>DIFF = 2;</code>
       */
      public static final int DIFF_VALUE = 2;
      /**
       * <code>MULT = 3;</code>
       */
      public static final int MULT_VALUE = 3;
      /**
       * <code>DIV = 4;</code>
       */
      public static final int DIV_VALUE = 4;
      /**
       * <code>MOD = 5;</code>
       */
      public static final int MOD_VALUE = 5;
      /**
       * <code>EXP = 6;</code>
       */
      public static final int EXP_VALUE = 6;
      /**
       * <code>ABS_YEAR = 7;</code>
       */
      public static final int ABS_YEAR_VALUE = 7;
      /**
       * <code>ABS_QUARTER = 8;</code>
       */
      public static final int ABS_QUARTER_VALUE = 8;
      /**
       * <code>ABS_MONTH = 9;</code>
       */
      public static final int ABS_MONTH_VALUE = 9;
      /**
       * <code>ABS_DAY = 10;</code>
       */
      public static final int ABS_DAY_VALUE = 10;
      /**
       * <code>QUARTER_IN_YEAR = 11;</code>
       */
      public static final int QUARTER_IN_YEAR_VALUE = 11;
      /**
       * <code>MONTH_IN_YEAR = 12;</code>
       */
      public static final int MONTH_IN_YEAR_VALUE = 12;
      /**
       * <code>DAY_IN_YEAR = 13;</code>
       */
      public static final int DAY_IN_YEAR_VALUE = 13;
      /**
       * <code>MONTH_IN_QUARTER = 14;</code>
       */
      public static final int MONTH_IN_QUARTER_VALUE = 14;
      /**
       * <code>DAY_IN_QUARTER = 15;</code>
       */
      public static final int DAY_IN_QUARTER_VALUE = 15;
      /**
       * <code>DAY_IN_MONTH = 16;</code>
       */
      public static final int DAY_IN_MONTH_VALUE = 16;
      /**
       * <code>DAY_OF_WEEK = 17;</code>
       */
      public static final int DAY_OF_WEEK_VALUE = 17;
      /**
       * <pre>
       * tags 18-20 unused
       * </pre>
       *
       * <code>ABS_YEAR_AS_EPOCH = 21;</code>
       */
      public static final int ABS_YEAR_AS_EPOCH_VALUE = 21;
      /**
       * <code>YEAR_START_EPOCH = 21;</code>
       */
      public static final int YEAR_START_EPOCH_VALUE = 21;
      /**
       * <code>ABS_QUARTER_AS_EPOCH = 22;</code>
       */
      public static final int ABS_QUARTER_AS_EPOCH_VALUE = 22;
      /**
       * <code>QUARTER_START_EPOCH = 22;</code>
       */
      public static final int QUARTER_START_EPOCH_VALUE = 22;
      /**
       * <code>ABS_MONTH_AS_EPOCH = 23;</code>
       */
      public static final int ABS_MONTH_AS_EPOCH_VALUE = 23;
      /**
       * <code>MONTH_START_EPOCH = 23;</code>
       */
      public static final int MONTH_START_EPOCH_VALUE = 23;
      /**
       * <code>ABS_DAY_AS_EPOCH = 24;</code>
       */
      public static final int ABS_DAY_AS_EPOCH_VALUE = 24;
      /**
       * <code>DAY_START_EPOCH = 24;</code>
       */
      public static final int DAY_START_EPOCH_VALUE = 24;
      /**
       * <code>WEEK_IN_YEAR = 25;</code>
       */
      public static final int WEEK_IN_YEAR_VALUE = 25;
      /**
       * <code>WEEK_IN_QUARTER = 26;</code>
       */
      public static final int WEEK_IN_QUARTER_VALUE = 26;
      /**
       * <code>WEEK_IN_MONTH = 27;</code>
       */
      public static final int WEEK_IN_MONTH_VALUE = 27;
      /**
       * <code>WEEK_IN_YEAR_AS_EPOCH = 28;</code>
       */
      public static final int WEEK_IN_YEAR_AS_EPOCH_VALUE = 28;
      /**
       * <code>WEEK_IN_QUARTER_AS_EPOCH = 29;</code>
       */
      public static final int WEEK_IN_QUARTER_AS_EPOCH_VALUE = 29;
      /**
       * <code>WEEK_IN_MONTH_AS_EPOCH = 30;</code>
       */
      public static final int WEEK_IN_MONTH_AS_EPOCH_VALUE = 30;
      /**
       * <code>ABS_HOUR = 31;</code>
       */
      public static final int ABS_HOUR_VALUE = 31;
      /**
       * <code>ABS_HOUR_AS_EPOCH = 32;</code>
       */
      public static final int ABS_HOUR_AS_EPOCH_VALUE = 32;
      /**
       * <code>HOUR_START_EPOCH = 32;</code>
       */
      public static final int HOUR_START_EPOCH_VALUE = 32;
      /**
       * <code>ABS_WEEK = 33;</code>
       */
      public static final int ABS_WEEK_VALUE = 33;
      /**
       * <pre>
       * ---------------------- DEPRECATED_END -----------------------------------
       * </pre>
       *
       * <code>WEEK_START_EPOCH = 34;</code>
       */
      public static final int WEEK_START_EPOCH_VALUE = 34;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static E valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static E forNumber(int value) {
        switch (value) {
          case 0: return OP_NONE;
          case 1: return OP_PLUS;
          case 2: return OP_MINUS;
          case 3: return OP_MULTIPLY;
          case 4: return OP_DIVIDE;
          case 5: return OP_MOD;
          case 6: return OP_EXP;
          case 7: return OP_ABS_YEAR;
          case 8: return OP_ABS_QUARTER;
          case 9: return OP_ABS_MONTH;
          case 10: return OP_ABS_DAY;
          case 11: return OP_QUARTER_IN_YEAR;
          case 12: return OP_MONTH_IN_YEAR;
          case 13: return OP_DAY_IN_YEAR;
          case 14: return OP_MONTH_IN_QUARTER;
          case 15: return OP_DAY_IN_QUARTER;
          case 16: return OP_DAY_IN_MONTH;
          case 17: return OP_DAY_OF_WEEK;
          case 21: return OP_YEAR_START_EPOCH;
          case 22: return OP_QUARTER_START_EPOCH;
          case 23: return OP_MONTH_START_EPOCH;
          case 24: return OP_DAY_START_EPOCH;
          case 25: return OP_WEEK_IN_YEAR;
          case 26: return OP_WEEK_IN_QUARTER;
          case 27: return OP_WEEK_IN_MONTH;
          case 28: return OP_WEEK_IN_YEAR_AS_EPOCH;
          case 29: return OP_WEEK_IN_QUARTER_AS_EPOCH;
          case 30: return OP_WEEK_IN_MONTH_AS_EPOCH;
          case 31: return OP_ABS_HOUR;
          case 32: return OP_HOUR_START_EPOCH;
          case 33: return OP_ABS_WEEK;
          case 34: return OP_WEEK_START_EPOCH;
          case 35: return OP_NOT;
          case 36: return OP_SQRT;
          case 37: return OP_STRLEN;
          case 38: return OP_IS_NULL;
          case 39: return OP_EQUALS;
          case 40: return OP_NOT_EQUALS;
          case 41: return OP_LESS_THAN;
          case 42: return OP_LESSER_EQUALS;
          case 43: return OP_GREATER_THAN;
          case 44: return OP_GREATER_EQUALS;
          case 45: return OP_AND;
          case 46: return OP_OR;
          case 47: return OP_BEGINS_WITH;
          case 48: return OP_ENDS_WITH;
          case 49: return OP_CONTAINS;
          case 50: return OP_EQUALS_NOCASE;
          case 51: return OP_NOT_EQUALS_NOCASE;
          case 52: return OP_LESS_THAN_NOCASE;
          case 53: return OP_LESSER_EQUALS_NOCASE;
          case 54: return OP_GREATER_THAN_NOCASE;
          case 55: return OP_GREATER_EQUALS_NOCASE;
          case 56: return OP_BEGINS_WITH_NOCASE;
          case 57: return OP_ENDS_WITH_NOCASE;
          case 58: return OP_CONTAINS_NOCASE;
          case 59: return OP_NEGATE;
          case 60: return OP_ABS;
          case 61: return OP_FLOOR;
          case 62: return OP_CEIL;
          case 63: return OP_SQUARE;
          case 64: return OP_CUBE;
          case 65: return OP_CUBEROOT;
          case 66: return OP_EXP2;
          case 67: return OP_LN;
          case 68: return OP_LOG2;
          case 69: return OP_LOG10;
          case 70: return OP_SIGN;
          case 71: return OP_POW;
          case 72: return OP_LEAST;
          case 73: return OP_GREATEST;
          case 74: return OP_DATE_DIFF_DAYS;
          case 75: return OP_COS;
          case 76: return OP_SIN;
          case 77: return OP_TAN;
          case 78: return OP_ACOS;
          case 79: return OP_ASIN;
          case 80: return OP_ATAN;
          case 81: return OP_ATAN2;
          case 82: return OP_IF_NULL;
          case 83: return OP_IF;
          case 84: return OP_RANDOM;
          case 85: return OP_ROUND;
          case 86: return OP_STRPOS;
          case 87: return OP_NOW;
          case 88: return OP_SUBSTR;
          case 89: return OP_SPHERICAL_DISTANCE;
          case 90: return OP_IS_WEEKEND;
          case 91: return OP_DAY_OF_WEEK_STR;
          case 92: return OP_DATE_ADD_DAYS;
          case 93: return OP_HOUR_IN_DAY;
          case 94: return OP_SECOND_IN_DAY;
          case 95: return OP_MONTH_IN_YEAR_STR;
          case 96: return OP_IDENTITY;
          case 97: return OP_HASH;
          case 98: return OP_COMBINE_HASH;
          case 99: return OP_DATE_PARSE;
          case 100: return OP_TIME_PART;
          case 101: return OP_STRCAT;
          case 102: return OP_IN;
          case 103: return OP_CONVERT_BOOL_NUMERIC;
          case 104: return OP_CONVERT_BOOL_STRING;
          case 105: return OP_CONVERT_NUMERIC_BOOL;
          case 106: return OP_CONVERT_STRING_BOOL;
          case 107: return OP_CONVERT_FLOAT_INTEGER;
          case 108: return OP_CONVERT_STRING_INT64;
          case 109: return OP_CONVERT_STRING_DOUBLE;
          case 110: return OP_CONVERT_INT64_STRING;
          case 111: return OP_CONVERT_DOUBLE_STRING;
          case 112: return OP_CONVERT_DATE_STRING;
          case 113: return OP_SPELLS_LIKE;
          case 114: return OP_SOUNDS_LIKE;
          case 115: return OP_LIKE;
          case 116: return OP_STRING_MATCH_SCORE;
          case 117: return OP_EDIT_DISTANCE;
          case 118: return OP_EDIT_DISTANCE_WITH_CAP;
          case 119: return OP_TODAY;
          case 120: return OP_APPROX_SET_CARDINALITY;
          case 121: return OP_CONTAINER_SIZE;
          case 122: return OP_CONVERT_STRING_FLOAT;
          case 123: return OP_WEEK_IN_YEAR_ISO;
          case 124: return OP_CONVERT_INTEGER_DOUBLE;
          case 127: return OP_DATE_ADD_WEEKS;
          case 128: return OP_DATE_ADD_MONTHS;
          case 129: return OP_DATE_TIME_ADD_SECONDS;
          case 130: return OP_DATE_TIME_ADD_MINUTES;
          case 131: return OP_DATE_ADD_YEARS;
          case 132: return OP_NORMALIZE_STRING;
          case 133: return OP_NORMALIZE_STRING_PRESERVE_CASE;
          case 134: return OP_LEFT;
          case 135: return OP_RIGHT;
          case 136: return OP_UTF8_STRLEN;
          case 137: return OP_UTF8_SUBSTR;
          case 138: return OP_UTF8_LEFT;
          case 139: return OP_UTF8_RIGHT;
          case 140: return OP_UTF8_STRPOS;
          case 141: return OP_NUM_OPS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<E>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          E> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<E>() {
              public E findValueByNumber(int number) {
                return E.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return Ops.ExpressionOp.getDescriptor().getEnumTypes().get(0);
      }

      private static final E[] VALUES = getStaticValuesArray();
      private static E[] getStaticValuesArray() {
        return new E[] {
          OP_NONE, OP_PLUS, OP_MINUS, OP_MULTIPLY, OP_DIVIDE, OP_MOD, OP_EXP, OP_ABS_YEAR, OP_ABS_QUARTER, OP_ABS_MONTH, OP_ABS_DAY, OP_QUARTER_IN_YEAR, OP_MONTH_IN_YEAR, OP_DAY_IN_YEAR, OP_MONTH_IN_QUARTER, OP_DAY_IN_QUARTER, OP_DAY_IN_MONTH, OP_DAY_OF_WEEK, OP_YEAR_START_EPOCH, OP_QUARTER_START_EPOCH, OP_MONTH_START_EPOCH, OP_DAY_START_EPOCH, OP_WEEK_IN_YEAR, OP_WEEK_IN_QUARTER, OP_WEEK_IN_MONTH, OP_WEEK_IN_YEAR_AS_EPOCH, OP_WEEK_IN_QUARTER_AS_EPOCH, OP_WEEK_IN_MONTH_AS_EPOCH, OP_ABS_HOUR, OP_HOUR_START_EPOCH, OP_ABS_WEEK, OP_WEEK_START_EPOCH, OP_NOT, OP_SQRT, OP_STRLEN, OP_IS_NULL, OP_EQUALS, OP_NOT_EQUALS, OP_LESS_THAN, OP_LESSER_EQUALS, OP_GREATER_THAN, OP_GREATER_EQUALS, OP_AND, OP_OR, OP_BEGINS_WITH, OP_ENDS_WITH, OP_CONTAINS, OP_EQUALS_NOCASE, OP_NOT_EQUALS_NOCASE, OP_LESS_THAN_NOCASE, OP_LESSER_EQUALS_NOCASE, OP_GREATER_THAN_NOCASE, OP_GREATER_EQUALS_NOCASE, OP_BEGINS_WITH_NOCASE, OP_ENDS_WITH_NOCASE, OP_CONTAINS_NOCASE, OP_NEGATE, OP_ABS, OP_FLOOR, OP_CEIL, OP_SQUARE, OP_CUBE, OP_CUBEROOT, OP_EXP2, OP_LN, OP_LOG2, OP_LOG10, OP_SIGN, OP_POW, OP_LEAST, OP_GREATEST, OP_DATE_DIFF_DAYS, OP_COS, OP_SIN, OP_TAN, OP_ACOS, OP_ASIN, OP_ATAN, OP_ATAN2, OP_IF_NULL, OP_IF, OP_RANDOM, OP_ROUND, OP_STRPOS, OP_NOW, OP_SUBSTR, OP_SPHERICAL_DISTANCE, OP_IS_WEEKEND, OP_DAY_OF_WEEK_STR, OP_DATE_ADD_DAYS, OP_HOUR_IN_DAY, OP_SECOND_IN_DAY, OP_MONTH_IN_YEAR_STR, OP_IDENTITY, OP_HASH, OP_COMBINE_HASH, OP_DATE_PARSE, OP_TIME_PART, OP_STRCAT, OP_IN, OP_CONVERT_BOOL_NUMERIC, OP_CONVERT_BOOL_STRING, OP_CONVERT_NUMERIC_BOOL, OP_CONVERT_STRING_BOOL, OP_CONVERT_FLOAT_INTEGER, OP_CONVERT_STRING_INT64, OP_CONVERT_STRING_DOUBLE, OP_CONVERT_INT64_STRING, OP_CONVERT_DOUBLE_STRING, OP_CONVERT_DATE_STRING, OP_SPELLS_LIKE, OP_SOUNDS_LIKE, OP_LIKE, OP_STRING_MATCH_SCORE, OP_EDIT_DISTANCE, OP_EDIT_DISTANCE_WITH_CAP, OP_TODAY, OP_APPROX_SET_CARDINALITY, OP_CONTAINER_SIZE, OP_CONVERT_STRING_FLOAT, OP_WEEK_IN_YEAR_ISO, OP_CONVERT_INTEGER_DOUBLE, OP_DATE_ADD_WEEKS, OP_DATE_ADD_MONTHS, OP_DATE_TIME_ADD_SECONDS, OP_DATE_TIME_ADD_MINUTES, OP_DATE_ADD_YEARS, OP_NORMALIZE_STRING, OP_NORMALIZE_STRING_PRESERVE_CASE, OP_LEFT, OP_RIGHT, OP_UTF8_STRLEN, OP_UTF8_SUBSTR, OP_UTF8_LEFT, OP_UTF8_RIGHT, OP_UTF8_STRPOS, OP_NUM_OPS, NONE, SUM, DIFF, MULT, DIV, MOD, EXP, ABS_YEAR, ABS_QUARTER, ABS_MONTH, ABS_DAY, QUARTER_IN_YEAR, MONTH_IN_YEAR, DAY_IN_YEAR, MONTH_IN_QUARTER, DAY_IN_QUARTER, DAY_IN_MONTH, DAY_OF_WEEK, ABS_YEAR_AS_EPOCH, YEAR_START_EPOCH, ABS_QUARTER_AS_EPOCH, QUARTER_START_EPOCH, ABS_MONTH_AS_EPOCH, MONTH_START_EPOCH, ABS_DAY_AS_EPOCH, DAY_START_EPOCH, WEEK_IN_YEAR, WEEK_IN_QUARTER, WEEK_IN_MONTH, WEEK_IN_YEAR_AS_EPOCH, WEEK_IN_QUARTER_AS_EPOCH, WEEK_IN_MONTH_AS_EPOCH, ABS_HOUR, ABS_HOUR_AS_EPOCH, HOUR_START_EPOCH, ABS_WEEK, WEEK_START_EPOCH, 
        };
      }
      public static E valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private E(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:ExpressionOp.E)
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Ops.ExpressionOp)) {
        return super.equals(obj);
      }
      Ops.ExpressionOp other = (Ops.ExpressionOp) obj;

      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Ops.ExpressionOp parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Ops.ExpressionOp parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Ops.ExpressionOp parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Ops.ExpressionOp parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Ops.ExpressionOp parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Ops.ExpressionOp parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Ops.ExpressionOp parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Ops.ExpressionOp parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static Ops.ExpressionOp parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static Ops.ExpressionOp parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Ops.ExpressionOp parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Ops.ExpressionOp parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Ops.ExpressionOp prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code ExpressionOp}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:ExpressionOp)
        Ops.ExpressionOpOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Ops.internal_static_ExpressionOp_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Ops.internal_static_ExpressionOp_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Ops.ExpressionOp.class, Ops.ExpressionOp.Builder.class);
      }

      // Construct using Ops.ExpressionOp.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Ops.internal_static_ExpressionOp_descriptor;
      }

      @java.lang.Override
      public Ops.ExpressionOp getDefaultInstanceForType() {
        return Ops.ExpressionOp.getDefaultInstance();
      }

      @java.lang.Override
      public Ops.ExpressionOp build() {
        Ops.ExpressionOp result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Ops.ExpressionOp buildPartial() {
        Ops.ExpressionOp result = new Ops.ExpressionOp(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Ops.ExpressionOp) {
          return mergeFrom((Ops.ExpressionOp)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Ops.ExpressionOp other) {
        if (other == Ops.ExpressionOp.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Ops.ExpressionOp parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (Ops.ExpressionOp) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:ExpressionOp)
    }

    // @@protoc_insertion_point(class_scope:ExpressionOp)
    private static final Ops.ExpressionOp DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Ops.ExpressionOp();
    }

    public static Ops.ExpressionOp getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ExpressionOp>
        PARSER = new com.google.protobuf.AbstractParser<ExpressionOp>() {
      @java.lang.Override
      public ExpressionOp parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ExpressionOp(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ExpressionOp> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExpressionOp> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Ops.ExpressionOp getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_AggregateOp_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_AggregateOp_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_ExpressionOp_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_ExpressionOp_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\tops.proto\"\277\006\n\013AggregateOp\"\257\006\n\001E\022\r\n\tAGG" +
      "R_NONE\020\000\022\014\n\010AGGR_SUM\020\001\022\020\n\014AGGR_AVERAGE\020\002" +
      "\022\027\n\023AGGR_COUNT_NON_NULL\020\003\022\014\n\010AGGR_MIN\020\004\022" +
      "\014\n\010AGGR_MAX\020\005\022\021\n\rAGGR_VARIANCE\020\006\022\016\n\nAGGR" +
      "_STDEV\020\007\022\017\n\013AGGR_GROWTH\020\010\022\017\n\013AGGR_MEDIAN" +
      "\020\t\022\027\n\023AGGR_COUNT_DISTINCT\020\n\022\030\n\024AGGR_COUN" +
      "T_WITH_NULL\020\013\022\023\n\017AGGR_ROW_NUMBER\020\014\022\r\n\tAG" +
      "GR_RANK\020\r\022\023\n\017AGGR_DENSE_RANK\020\016\022\036\n\032AGGR_A" +
      "PPROX_COUNT_DISTINCT\020\017\022\021\n\rAGGR_DISTINCT\020" +
      "\020\022\016\n\nAGGR_NTILE\020\021\022\032\n\026AGGR_COUNT_DISTINCT" +
      "_V1\020\023\022%\n!AGGR_PERCENTILE_CONT_WITHIN_GRO" +
      "UP\020\024\022%\n!AGGR_PERCENTILE_DISC_WITHIN_GROU" +
      "P\020\025\022\024\n\020AGGR_VALUE_BREAK\020\026\022\025\n\021AGGR_PERCEN" +
      "T_RANK\020\027\022 \n\034AGGR_COUNT_DISTINCT_NON_NULL" +
      "\020\030\022\032\n\026AGGR_DISTINCT_NON_NULL\020\031\022\030\n\024AGGR_A" +
      "PPROX_DISTINCT\020\032\022\036\n\032AGGR_APPROX_DISTINCT" +
      "_MERGE\020\033\022\010\n\004NONE\020\000\022\007\n\003SUM\020\001\022\007\n\003AVG\020\002\022\t\n\005" +
      "COUNT\020\003\022\022\n\016COUNT_NON_NULL\020\003\022\007\n\003MIN\020\004\022\007\n\003" +
      "MAX\020\005\022\014\n\010VARIANCE\020\006\022\t\n\005STDEV\020\007\022\n\n\006GROWTH" +
      "\020\010\022\n\n\006MEDIAN\020\t\022\022\n\016COUNT_DISTINCT\020\n\022\023\n\017CO" +
      "UNT_WITH_NULL\020\013\022\030\n\024AGGR_RANK_PERCENTILE\020" +
      "\022\032\002\020\001\"\227\033\n\014ExpressionOp\"\206\033\n\001E\022\013\n\007OP_NONE\020" +
      "\000\022\013\n\007OP_PLUS\020\001\022\014\n\010OP_MINUS\020\002\022\017\n\013OP_MULTI" +
      "PLY\020\003\022\r\n\tOP_DIVIDE\020\004\022\n\n\006OP_MOD\020\005\022\n\n\006OP_E" +
      "XP\020\006\022\017\n\013OP_ABS_YEAR\020\007\022\022\n\016OP_ABS_QUARTER\020" +
      "\010\022\020\n\014OP_ABS_MONTH\020\t\022\016\n\nOP_ABS_DAY\020\n\022\026\n\022O" +
      "P_QUARTER_IN_YEAR\020\013\022\024\n\020OP_MONTH_IN_YEAR\020" +
      "\014\022\022\n\016OP_DAY_IN_YEAR\020\r\022\027\n\023OP_MONTH_IN_QUA" +
      "RTER\020\016\022\025\n\021OP_DAY_IN_QUARTER\020\017\022\023\n\017OP_DAY_" +
      "IN_MONTH\020\020\022\022\n\016OP_DAY_OF_WEEK\020\021\022\027\n\023OP_YEA" +
      "R_START_EPOCH\020\025\022\032\n\026OP_QUARTER_START_EPOC" +
      "H\020\026\022\030\n\024OP_MONTH_START_EPOCH\020\027\022\026\n\022OP_DAY_" +
      "START_EPOCH\020\030\022\023\n\017OP_WEEK_IN_YEAR\020\031\022\026\n\022OP" +
      "_WEEK_IN_QUARTER\020\032\022\024\n\020OP_WEEK_IN_MONTH\020\033" +
      "\022\034\n\030OP_WEEK_IN_YEAR_AS_EPOCH\020\034\022\037\n\033OP_WEE" +
      "K_IN_QUARTER_AS_EPOCH\020\035\022\035\n\031OP_WEEK_IN_MO" +
      "NTH_AS_EPOCH\020\036\022\017\n\013OP_ABS_HOUR\020\037\022\027\n\023OP_HO" +
      "UR_START_EPOCH\020 \022\017\n\013OP_ABS_WEEK\020!\022\027\n\023OP_" +
      "WEEK_START_EPOCH\020\"\022\n\n\006OP_NOT\020#\022\013\n\007OP_SQR" +
      "T\020$\022\r\n\tOP_STRLEN\020%\022\016\n\nOP_IS_NULL\020&\022\r\n\tOP" +
      "_EQUALS\020\'\022\021\n\rOP_NOT_EQUALS\020(\022\020\n\014OP_LESS_" +
      "THAN\020)\022\024\n\020OP_LESSER_EQUALS\020*\022\023\n\017OP_GREAT" +
      "ER_THAN\020+\022\025\n\021OP_GREATER_EQUALS\020,\022\n\n\006OP_A" +
      "ND\020-\022\t\n\005OP_OR\020.\022\022\n\016OP_BEGINS_WITH\020/\022\020\n\014O" +
      "P_ENDS_WITH\0200\022\017\n\013OP_CONTAINS\0201\022\024\n\020OP_EQU" +
      "ALS_NOCASE\0202\022\030\n\024OP_NOT_EQUALS_NOCASE\0203\022\027" +
      "\n\023OP_LESS_THAN_NOCASE\0204\022\033\n\027OP_LESSER_EQU" +
      "ALS_NOCASE\0205\022\032\n\026OP_GREATER_THAN_NOCASE\0206" +
      "\022\034\n\030OP_GREATER_EQUALS_NOCASE\0207\022\031\n\025OP_BEG" +
      "INS_WITH_NOCASE\0208\022\027\n\023OP_ENDS_WITH_NOCASE" +
      "\0209\022\026\n\022OP_CONTAINS_NOCASE\020:\022\r\n\tOP_NEGATE\020" +
      ";\022\n\n\006OP_ABS\020<\022\014\n\010OP_FLOOR\020=\022\013\n\007OP_CEIL\020>" +
      "\022\r\n\tOP_SQUARE\020?\022\013\n\007OP_CUBE\020@\022\017\n\013OP_CUBER" +
      "OOT\020A\022\013\n\007OP_EXP2\020B\022\t\n\005OP_LN\020C\022\013\n\007OP_LOG2" +
      "\020D\022\014\n\010OP_LOG10\020E\022\013\n\007OP_SIGN\020F\022\n\n\006OP_POW\020" +
      "G\022\014\n\010OP_LEAST\020H\022\017\n\013OP_GREATEST\020I\022\025\n\021OP_D" +
      "ATE_DIFF_DAYS\020J\022\n\n\006OP_COS\020K\022\n\n\006OP_SIN\020L\022" +
      "\n\n\006OP_TAN\020M\022\013\n\007OP_ACOS\020N\022\013\n\007OP_ASIN\020O\022\013\n" +
      "\007OP_ATAN\020P\022\014\n\010OP_ATAN2\020Q\022\016\n\nOP_IF_NULL\020R" +
      "\022\t\n\005OP_IF\020S\022\r\n\tOP_RANDOM\020T\022\014\n\010OP_ROUND\020U" +
      "\022\r\n\tOP_STRPOS\020V\022\n\n\006OP_NOW\020W\022\r\n\tOP_SUBSTR" +
      "\020X\022\031\n\025OP_SPHERICAL_DISTANCE\020Y\022\021\n\rOP_IS_W" +
      "EEKEND\020Z\022\026\n\022OP_DAY_OF_WEEK_STR\020[\022\024\n\020OP_D" +
      "ATE_ADD_DAYS\020\\\022\022\n\016OP_HOUR_IN_DAY\020]\022\024\n\020OP" +
      "_SECOND_IN_DAY\020^\022\030\n\024OP_MONTH_IN_YEAR_STR" +
      "\020_\022\017\n\013OP_IDENTITY\020`\022\013\n\007OP_HASH\020a\022\023\n\017OP_C" +
      "OMBINE_HASH\020b\022\021\n\rOP_DATE_PARSE\020c\022\020\n\014OP_T" +
      "IME_PART\020d\022\r\n\tOP_STRCAT\020e\022\t\n\005OP_IN\020f\022\033\n\027" +
      "OP_CONVERT_BOOL_NUMERIC\020g\022\032\n\026OP_CONVERT_" +
      "BOOL_STRING\020h\022\033\n\027OP_CONVERT_NUMERIC_BOOL" +
      "\020i\022\032\n\026OP_CONVERT_STRING_BOOL\020j\022\034\n\030OP_CON" +
      "VERT_FLOAT_INTEGER\020k\022\033\n\027OP_CONVERT_STRIN" +
      "G_INT64\020l\022\034\n\030OP_CONVERT_STRING_DOUBLE\020m\022" +
      "\033\n\027OP_CONVERT_INT64_STRING\020n\022\034\n\030OP_CONVE" +
      "RT_DOUBLE_STRING\020o\022\032\n\026OP_CONVERT_DATE_ST" +
      "RING\020p\022\022\n\016OP_SPELLS_LIKE\020q\022\022\n\016OP_SOUNDS_" +
      "LIKE\020r\022\013\n\007OP_LIKE\020s\022\031\n\025OP_STRING_MATCH_S" +
      "CORE\020t\022\024\n\020OP_EDIT_DISTANCE\020u\022\035\n\031OP_EDIT_" +
      "DISTANCE_WITH_CAP\020v\022\014\n\010OP_TODAY\020w\022\035\n\031OP_" +
      "APPROX_SET_CARDINALITY\020x\022\025\n\021OP_CONTAINER" +
      "_SIZE\020y\022\033\n\027OP_CONVERT_STRING_FLOAT\020z\022\027\n\023" +
      "OP_WEEK_IN_YEAR_ISO\020{\022\035\n\031OP_CONVERT_INTE" +
      "GER_DOUBLE\020|\022\025\n\021OP_DATE_ADD_WEEKS\020\177\022\027\n\022O" +
      "P_DATE_ADD_MONTHS\020\200\001\022\035\n\030OP_DATE_TIME_ADD" +
      "_SECONDS\020\201\001\022\035\n\030OP_DATE_TIME_ADD_MINUTES\020" +
      "\202\001\022\026\n\021OP_DATE_ADD_YEARS\020\203\001\022\030\n\023OP_NORMALI" +
      "ZE_STRING\020\204\001\022&\n!OP_NORMALIZE_STRING_PRES" +
      "ERVE_CASE\020\205\001\022\014\n\007OP_LEFT\020\206\001\022\r\n\010OP_RIGHT\020\207" +
      "\001\022\023\n\016OP_UTF8_STRLEN\020\210\001\022\023\n\016OP_UTF8_SUBSTR" +
      "\020\211\001\022\021\n\014OP_UTF8_LEFT\020\212\001\022\022\n\rOP_UTF8_RIGHT\020" +
      "\213\001\022\023\n\016OP_UTF8_STRPOS\020\214\001\022\017\n\nOP_NUM_OPS\020\215\001" +
      "\022\010\n\004NONE\020\000\022\007\n\003SUM\020\001\022\010\n\004DIFF\020\002\022\010\n\004MULT\020\003\022" +
      "\007\n\003DIV\020\004\022\007\n\003MOD\020\005\022\007\n\003EXP\020\006\022\014\n\010ABS_YEAR\020\007" +
      "\022\017\n\013ABS_QUARTER\020\010\022\r\n\tABS_MONTH\020\t\022\013\n\007ABS_" +
      "DAY\020\n\022\023\n\017QUARTER_IN_YEAR\020\013\022\021\n\rMONTH_IN_Y" +
      "EAR\020\014\022\017\n\013DAY_IN_YEAR\020\r\022\024\n\020MONTH_IN_QUART" +
      "ER\020\016\022\022\n\016DAY_IN_QUARTER\020\017\022\020\n\014DAY_IN_MONTH" +
      "\020\020\022\017\n\013DAY_OF_WEEK\020\021\022\025\n\021ABS_YEAR_AS_EPOCH" +
      "\020\025\022\024\n\020YEAR_START_EPOCH\020\025\022\030\n\024ABS_QUARTER_" +
      "AS_EPOCH\020\026\022\027\n\023QUARTER_START_EPOCH\020\026\022\026\n\022A" +
      "BS_MONTH_AS_EPOCH\020\027\022\025\n\021MONTH_START_EPOCH" +
      "\020\027\022\024\n\020ABS_DAY_AS_EPOCH\020\030\022\023\n\017DAY_START_EP" +
      "OCH\020\030\022\020\n\014WEEK_IN_YEAR\020\031\022\023\n\017WEEK_IN_QUART" +
      "ER\020\032\022\021\n\rWEEK_IN_MONTH\020\033\022\031\n\025WEEK_IN_YEAR_" +
      "AS_EPOCH\020\034\022\034\n\030WEEK_IN_QUARTER_AS_EPOCH\020\035" +
      "\022\032\n\026WEEK_IN_MONTH_AS_EPOCH\020\036\022\014\n\010ABS_HOUR" +
      "\020\037\022\025\n\021ABS_HOUR_AS_EPOCH\020 \022\024\n\020HOUR_START_" +
      "EPOCH\020 \022\014\n\010ABS_WEEK\020!\022\024\n\020WEEK_START_EPOC" +
      "H\020\"\032\002\020\001"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_AggregateOp_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_AggregateOp_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_AggregateOp_descriptor,
        new java.lang.String[] { });
    internal_static_ExpressionOp_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_ExpressionOp_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_ExpressionOp_descriptor,
        new java.lang.String[] { });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
